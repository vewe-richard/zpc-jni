/******************************************************************************
 * # License
 * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
/**
 *
 * @file dotdot_mqtt.h
 * @defgroup dotdot_mqtt DotDot Serializer
 * @ingroup uic_components
 *
 * @brief This component provides helper functions for parsing and generates UIC
 * json payloads sent over MQTT.
 *
 * @startuml
   participant "MQTT" as mqtt
   participant "DotDot MQTT" as dotdot
   participant "OnOff Mapper" as onoff

   note over mqtt, onoff
   In this example only OnOff mappers are shown.
   But there should exist mappers for all supported ZCL Clusters.
   In addition only a selection of the supported commands for each of these mappers are shown here.
   end note
   === Initialization ==
   onoff    -> dotdot: uic_mqtt_dotdot_on_off_on_callback_set(on_cb)
   onoff    -> dotdot: uic_mqtt_dotdot_on_off_off_callback_set(off_cb)
   onoff    -> dotdot: uic_mqtt_dotdot_set_on_off_write_attributes_callback(on_att_cb)

   note over dotdot: uic_mqtt_dotdot_init() is called

   dotdot -> mqtt:     uic_mqtt_subscribe("ucl/by-unid/+/+/OnOff/Commands/On", ...);
   dotdot -> mqtt:     uic_mqtt_subscribe("ucl/by-unid/+/+/OnOff/Commands/Off", ...);
   dotdot -> mqtt:     uic_mqtt_subscribe("ucl/by-unid/+/+/OnOff/Commands/WriteAttributes", ...)
   ... ...
   note over onoff: An end device is added
   onoff -> dotdot:    uic_mqtt_dotdot_publish_supported_commands(unid, endpoint)
   dotdot -> onoff:    on_cb(unid, endpoint, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK)
   dotdot -> onoff:    off_cb(unid, endpoint, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK)

   note over dotdot, onoff
   When uic_mqtt_dotdot_publish_supported_commands is called,
   DotDot MQTT calls all registered OnOff command callback functions
   with UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK.
   When the Command is supported by the unid/endpoint
   SL_STATUS_OK shall be returned, otherwise SL_STATUS_NOT_AVAILABLE.

   In this example both callbacks returns SL_STATUS_OK
   end note

   dotdot -> mqtt:     uic_mqtt_publish("ucl/by-unid/<unid>/ep<x>/OnOff/SupportedCommands", "[\"On\", \"Off\"]")
   ... ...
   note over mqtt: IoT Service has published an OnOff/Commands/Off
   mqtt -> dotdot:     uic_mqtt_dotdot_on_on_off_off(topic, message)
   dotdot -> onoff:    on_cb(unid, endpoint, UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL)

   @enduml
 * @{
 */

#ifndef DOTDOT_MQTT_H
#define DOTDOT_MQTT_H

#include <stdint.h>
#include <stdbool.h>

#include "sl_status.h"
#include "uic_typedefs.h"
#include "zap-types.h"
#include "uic_mqtt.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/** @brief Attribute publish type */
typedef enum {
  /** Publish Desired */
  UCL_MQTT_PUBLISH_TYPE_DESIRED   = 0x01,
  /** Publish Reported */
  UCL_MQTT_PUBLISH_TYPE_REPORTED  = 0x02,
  /** Publish all types (Desired and Reported) */
  UCL_MQTT_PUBLISH_TYPE_ALL       = 0xFF
} uic_mqtt_dotdot_attribute_publish_type_t;

/** @brief Callback type, used in uic_mqtt_dotdot callback functions */
typedef enum {
  /** Normal callback type */
  UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
  /** Support check type, check if the callback is supported by unid/endpoint */
  UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
} uic_mqtt_dotdot_callback_call_type_t;

// Initialize all dotdot available clusters
sl_status_t uic_mqtt_dotdot_init();

// Callback types used by the basic cluster
typedef sl_status_t (*uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);

typedef struct {
  uint8_t zcl_version;
  uint8_t application_version;
  uint8_t stack_version;
  uint8_t hw_version;
  const char* manufacturer_name;
  const char* model_identifier;
  const char* date_code;
  uint8_t power_source;
  uint8_t generic_device_class;
  uint8_t generic_device_type;
  const char* product_code;
  const char* producturl;
  const char* manufacturer_version_details;
  const char* serial_number;
  const char* product_label;
  const char* location_description;
  uint8_t physical_environment;
  bool device_enabled;
  uint8_t alarm_mask;
  uint8_t disable_local_config;
  const char* sw_buildid;
} uic_mqtt_dotdot_basic_state_t;

typedef struct {
  bool zcl_version;
  bool application_version;
  bool stack_version;
  bool hw_version;
  bool manufacturer_name;
  bool model_identifier;
  bool date_code;
  bool power_source;
  bool generic_device_class;
  bool generic_device_type;
  bool product_code;
  bool producturl;
  bool manufacturer_version_details;
  bool serial_number;
  bool product_label;
  bool location_description;
  bool physical_environment;
  bool device_enabled;
  bool alarm_mask;
  bool disable_local_config;
  bool sw_buildid;
} uic_mqtt_dotdot_basic_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_basic_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_basic_state_t,
    uic_mqtt_dotdot_basic_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_basic_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_basic_updated_state_t
);

typedef struct {
  bool reset_to_factory_defaults;
} uic_mqtt_dotdot_basic_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Basic/reset_to_factory_defaults is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/basic/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_basic_write_attributes_callback(
  const uic_mqtt_dotdot_basic_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/basic/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_basic_force_read_attributes_callback(
  const uic_mqtt_dotdot_basic_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Basic/Attributes/ZCLVersion
 *
 * @param base_topic    topic prefix to publish, /zcl_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_zcl_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ApplicationVersion
 *
 * @param base_topic    topic prefix to publish, /application_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_application_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/StackVersion
 *
 * @param base_topic    topic prefix to publish, /stack_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_stack_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/HWVersion
 *
 * @param base_topic    topic prefix to publish, /hw_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_hw_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ManufacturerName
 *
 * @param base_topic    topic prefix to publish, /manufacturer_name
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_manufacturer_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ModelIdentifier
 *
 * @param base_topic    topic prefix to publish, /model_identifier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_model_identifier_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/DateCode
 *
 * @param base_topic    topic prefix to publish, /date_code
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_date_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/PowerSource
 *
 * @param base_topic    topic prefix to publish, /power_source
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_power_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/GenericDevice-Class
 *
 * @param base_topic    topic prefix to publish, /generic_device_class
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_generic_device_class_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/GenericDevice-Type
 *
 * @param base_topic    topic prefix to publish, /generic_device_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_generic_device_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ProductCode
 *
 * @param base_topic    topic prefix to publish, /product_code
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_product_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ProductURL
 *
 * @param base_topic    topic prefix to publish, /producturl
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_producturl_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ManufacturerVersionDetails
 *
 * @param base_topic    topic prefix to publish, /manufacturer_version_details
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/SerialNumber
 *
 * @param base_topic    topic prefix to publish, /serial_number
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_serial_number_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/ProductLabel
 *
 * @param base_topic    topic prefix to publish, /product_label
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_product_label_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/LocationDescription
 *
 * @param base_topic    topic prefix to publish, /location_description
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_location_description_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/PhysicalEnvironment
 *
 * @param base_topic    topic prefix to publish, /physical_environment
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_physical_environment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/DeviceEnabled
 *
 * @param base_topic    topic prefix to publish, /device_enabled
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_device_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/AlarmMask
 *
 * @param base_topic    topic prefix to publish, /alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/DisableLocalConfig
 *
 * @param base_topic    topic prefix to publish, /disable_local_config
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_disable_local_config_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Basic/Attributes/SWBuildID
 *
 * @param base_topic    topic prefix to publish, /sw_buildid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_basic_sw_buildid_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Basic/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Basic/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_basic_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the power_configuration cluster

typedef struct {
  uint16_t mains_voltage;
  uint8_t mains_frequency;
  uint8_t mains_alarm_mask;
  uint16_t mains_voltage_min_threshold;
  uint16_t mains_voltage_max_threshold;
  uint16_t mains_voltage_dwell_trip_point;
  uint8_t battery_voltage;
  uint8_t battery_percentage_remaining;
  const char* battery_manufacturer;
  uint8_t battery_size;
  uint16_t batterya_hr_rating;
  uint8_t battery_quantity;
  uint8_t battery_rated_voltage;
  uint8_t battery_alarm_mask;
  uint8_t battery_voltage_min_threshold;
  uint8_t battery_voltage_threshold1;
  uint8_t battery_voltage_threshold2;
  uint8_t battery_voltage_threshold3;
  uint8_t battery_percentage_min_threshold;
  uint8_t battery_percentage_threshold1;
  uint8_t battery_percentage_threshold2;
  uint8_t battery_percentage_threshold3;
  uint32_t battery_alarm_state;
  uint8_t battery2_voltage;
  uint8_t battery2_percentage_remaining;
  const char* battery2_manufacturer;
  uint8_t battery2_size;
  uint16_t battery2a_hr_rating;
  uint8_t battery2_quantity;
  uint8_t battery2_rated_voltage;
  uint8_t battery2_alarm_mask;
  uint8_t battery2_voltage_min_threshold;
  uint8_t battery2_voltage_threshold1;
  uint8_t battery2_voltage_threshold2;
  uint8_t battery2_voltage_threshold3;
  uint8_t battery2_percentage_min_threshold;
  uint8_t battery2_percentage_threshold1;
  uint8_t battery2_percentage_threshold2;
  uint8_t battery2_percentage_threshold3;
  uint32_t battery2_alarm_state;
  uint8_t battery3_voltage;
  uint8_t battery3_percentage_remaining;
  const char* battery3_manufacturer;
  uint8_t battery3_size;
  uint16_t battery3a_hr_rating;
  uint8_t battery3_quantity;
  uint8_t battery3_rated_voltage;
  uint8_t battery3_alarm_mask;
  uint8_t battery3_voltage_min_threshold;
  uint8_t battery3_voltage_threshold1;
  uint8_t battery3_voltage_threshold2;
  uint8_t battery3_voltage_threshold3;
  uint8_t battery3_percentage_min_threshold;
  uint8_t battery3_percentage_threshold1;
  uint8_t battery3_percentage_threshold2;
  uint8_t battery3_percentage_threshold3;
  uint32_t battery3_alarm_state;
} uic_mqtt_dotdot_power_configuration_state_t;

typedef struct {
  bool mains_voltage;
  bool mains_frequency;
  bool mains_alarm_mask;
  bool mains_voltage_min_threshold;
  bool mains_voltage_max_threshold;
  bool mains_voltage_dwell_trip_point;
  bool battery_voltage;
  bool battery_percentage_remaining;
  bool battery_manufacturer;
  bool battery_size;
  bool batterya_hr_rating;
  bool battery_quantity;
  bool battery_rated_voltage;
  bool battery_alarm_mask;
  bool battery_voltage_min_threshold;
  bool battery_voltage_threshold1;
  bool battery_voltage_threshold2;
  bool battery_voltage_threshold3;
  bool battery_percentage_min_threshold;
  bool battery_percentage_threshold1;
  bool battery_percentage_threshold2;
  bool battery_percentage_threshold3;
  bool battery_alarm_state;
  bool battery2_voltage;
  bool battery2_percentage_remaining;
  bool battery2_manufacturer;
  bool battery2_size;
  bool battery2a_hr_rating;
  bool battery2_quantity;
  bool battery2_rated_voltage;
  bool battery2_alarm_mask;
  bool battery2_voltage_min_threshold;
  bool battery2_voltage_threshold1;
  bool battery2_voltage_threshold2;
  bool battery2_voltage_threshold3;
  bool battery2_percentage_min_threshold;
  bool battery2_percentage_threshold1;
  bool battery2_percentage_threshold2;
  bool battery2_percentage_threshold3;
  bool battery2_alarm_state;
  bool battery3_voltage;
  bool battery3_percentage_remaining;
  bool battery3_manufacturer;
  bool battery3_size;
  bool battery3a_hr_rating;
  bool battery3_quantity;
  bool battery3_rated_voltage;
  bool battery3_alarm_mask;
  bool battery3_voltage_min_threshold;
  bool battery3_voltage_threshold1;
  bool battery3_voltage_threshold2;
  bool battery3_voltage_threshold3;
  bool battery3_percentage_min_threshold;
  bool battery3_percentage_threshold1;
  bool battery3_percentage_threshold2;
  bool battery3_percentage_threshold3;
  bool battery3_alarm_state;
} uic_mqtt_dotdot_power_configuration_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_power_configuration_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_power_configuration_state_t,
    uic_mqtt_dotdot_power_configuration_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_power_configuration_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_power_configuration_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/power_configuration/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_power_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/power_configuration/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_power_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsVoltage
 *
 * @param base_topic    topic prefix to publish, /mains_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsFrequency
 *
 * @param base_topic    topic prefix to publish, /mains_frequency
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsAlarmMask
 *
 * @param base_topic    topic prefix to publish, /mains_alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsVoltageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /mains_voltage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsVoltageMaxThreshold
 *
 * @param base_topic    topic prefix to publish, /mains_voltage_max_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/MainsVoltageDwellTripPoint
 *
 * @param base_topic    topic prefix to publish, /mains_voltage_dwell_trip_point
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryVoltage
 *
 * @param base_topic    topic prefix to publish, /battery_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryPercentageRemaining
 *
 * @param base_topic    topic prefix to publish, /battery_percentage_remaining
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryManufacturer
 *
 * @param base_topic    topic prefix to publish, /battery_manufacturer
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatterySize
 *
 * @param base_topic    topic prefix to publish, /battery_size
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryAHrRating
 *
 * @param base_topic    topic prefix to publish, /batterya_hr_rating
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryQuantity
 *
 * @param base_topic    topic prefix to publish, /battery_quantity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryRatedVoltage
 *
 * @param base_topic    topic prefix to publish, /battery_rated_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryAlarmMask
 *
 * @param base_topic    topic prefix to publish, /battery_alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryVoltageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery_voltage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryVoltageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery_voltage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryVoltageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery_voltage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryVoltageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery_voltage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryPercentageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery_percentage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryPercentageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery_percentage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryPercentageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery_percentage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryPercentageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery_percentage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/BatteryAlarmState
 *
 * @param base_topic    topic prefix to publish, /battery_alarm_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2Voltage
 *
 * @param base_topic    topic prefix to publish, /battery2_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2PercentageRemaining
 *
 * @param base_topic    topic prefix to publish, /battery2_percentage_remaining
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2Manufacturer
 *
 * @param base_topic    topic prefix to publish, /battery2_manufacturer
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2Size
 *
 * @param base_topic    topic prefix to publish, /battery2_size
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2AHrRating
 *
 * @param base_topic    topic prefix to publish, /battery2a_hr_rating
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2Quantity
 *
 * @param base_topic    topic prefix to publish, /battery2_quantity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2RatedVoltage
 *
 * @param base_topic    topic prefix to publish, /battery2_rated_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2AlarmMask
 *
 * @param base_topic    topic prefix to publish, /battery2_alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2VoltageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery2_voltage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2VoltageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery2_voltage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2VoltageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery2_voltage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2VoltageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery2_voltage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2PercentageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery2_percentage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2PercentageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery2_percentage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2PercentageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery2_percentage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2PercentageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery2_percentage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery2AlarmState
 *
 * @param base_topic    topic prefix to publish, /battery2_alarm_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3Voltage
 *
 * @param base_topic    topic prefix to publish, /battery3_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3PercentageRemaining
 *
 * @param base_topic    topic prefix to publish, /battery3_percentage_remaining
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3Manufacturer
 *
 * @param base_topic    topic prefix to publish, /battery3_manufacturer
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3Size
 *
 * @param base_topic    topic prefix to publish, /battery3_size
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3AHrRating
 *
 * @param base_topic    topic prefix to publish, /battery3a_hr_rating
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3Quantity
 *
 * @param base_topic    topic prefix to publish, /battery3_quantity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3RatedVoltage
 *
 * @param base_topic    topic prefix to publish, /battery3_rated_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3AlarmMask
 *
 * @param base_topic    topic prefix to publish, /battery3_alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3VoltageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery3_voltage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3VoltageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery3_voltage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3VoltageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery3_voltage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3VoltageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery3_voltage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3PercentageMinThreshold
 *
 * @param base_topic    topic prefix to publish, /battery3_percentage_min_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3PercentageThreshold1
 *
 * @param base_topic    topic prefix to publish, /battery3_percentage_threshold1
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3PercentageThreshold2
 *
 * @param base_topic    topic prefix to publish, /battery3_percentage_threshold2
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3PercentageThreshold3
 *
 * @param base_topic    topic prefix to publish, /battery3_percentage_threshold3
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PowerConfiguration/Attributes/Battery3AlarmState
 *
 * @param base_topic    topic prefix to publish, /battery3_alarm_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the PowerConfiguration/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /PowerConfiguration/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_power_configuration_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the device_temperature_configuration cluster

typedef struct {
  int16_t current_temperature;
  int16_t min_temp_experienced;
  int16_t max_temp_experienced;
  uint16_t over_temp_total_dwell;
  uint8_t device_temp_alarm_mask;
  int16_t low_temp_threshold;
  int16_t high_temp_threshold;
  uint32_t low_temp_dwell_trip_point;
  uint32_t high_temp_dwell_trip_point;
} uic_mqtt_dotdot_device_temperature_configuration_state_t;

typedef struct {
  bool current_temperature;
  bool min_temp_experienced;
  bool max_temp_experienced;
  bool over_temp_total_dwell;
  bool device_temp_alarm_mask;
  bool low_temp_threshold;
  bool high_temp_threshold;
  bool low_temp_dwell_trip_point;
  bool high_temp_dwell_trip_point;
} uic_mqtt_dotdot_device_temperature_configuration_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_device_temperature_configuration_state_t,
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_device_temperature_configuration_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/device_temperature_configuration/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_device_temperature_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/device_temperature_configuration/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_device_temperature_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/CurrentTemperature
 *
 * @param base_topic    topic prefix to publish, /current_temperature
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/MinTempExperienced
 *
 * @param base_topic    topic prefix to publish, /min_temp_experienced
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/MaxTempExperienced
 *
 * @param base_topic    topic prefix to publish, /max_temp_experienced
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell
 *
 * @param base_topic    topic prefix to publish, /over_temp_total_dwell
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask
 *
 * @param base_topic    topic prefix to publish, /device_temp_alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/LowTempThreshold
 *
 * @param base_topic    topic prefix to publish, /low_temp_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/HighTempThreshold
 *
 * @param base_topic    topic prefix to publish, /high_temp_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint
 *
 * @param base_topic    topic prefix to publish, /low_temp_dwell_trip_point
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint
 *
 * @param base_topic    topic prefix to publish, /high_temp_dwell_trip_point
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the DeviceTemperatureConfiguration/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /DeviceTemperatureConfiguration/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_device_temperature_configuration_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the identify cluster
typedef sl_status_t (*uic_mqtt_dotdot_identify_identify_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t identify_time
);
typedef sl_status_t (*uic_mqtt_dotdot_identify_identify_query_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t timeout
);
typedef sl_status_t (*uic_mqtt_dotdot_identify_identify_query_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_identify_trigger_effect_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    TriggerEffectEffectIdentifier effect_identifier,

    TriggerEffectEffectVariant effect_variant
);

typedef struct {
  uint16_t identify_time;
} uic_mqtt_dotdot_identify_state_t;

typedef struct {
  bool identify_time;
} uic_mqtt_dotdot_identify_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_identify_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_identify_state_t,
    uic_mqtt_dotdot_identify_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_identify_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_identify_updated_state_t
);

typedef struct {
  bool identify;
  bool identify_query_response;
  bool identify_query;
  bool trigger_effect;
} uic_mqtt_dotdot_identify_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Identify/identify is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_identify_identify_callback_set(const uic_mqtt_dotdot_identify_identify_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Identify/identify_query_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_identify_identify_query_response_callback_set(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Identify/identify_query is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_identify_identify_query_callback_set(const uic_mqtt_dotdot_identify_identify_query_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Identify/trigger_effect is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_identify_trigger_effect_callback_set(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/identify/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_identify_write_attributes_callback(
  const uic_mqtt_dotdot_identify_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/identify/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_identify_force_read_attributes_callback(
  const uic_mqtt_dotdot_identify_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Identify/Attributes/IdentifyTime
 *
 * @param base_topic    topic prefix to publish, /identify_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_identify_identify_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Identify/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Identify/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_identify_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the groups cluster
typedef sl_status_t (*uic_mqtt_dotdot_groups_add_group_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t group_id,

    const char* group_name
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_add_group_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t status,

    uint16_t group_id
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_view_group_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t group_id
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_view_group_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t status,

    uint16_t group_id,

    const char* group_name
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_get_group_membership_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t group_list
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_get_group_membership_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t capacity,

    uint16_t group_list
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_remove_group_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t group_id
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_remove_group_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t status,

    uint16_t group_id
);
typedef sl_status_t (*uic_mqtt_dotdot_groups_remove_all_groups_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t group_id,

    const char* group_name
);

typedef struct {
  uint8_t name_support;
} uic_mqtt_dotdot_groups_state_t;

typedef struct {
  bool name_support;
} uic_mqtt_dotdot_groups_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_groups_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_groups_state_t,
    uic_mqtt_dotdot_groups_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_groups_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_groups_updated_state_t
);

typedef struct {
  bool add_group;
  bool add_group_response;
  bool view_group;
  bool view_group_response;
  bool get_group_membership;
  bool get_group_membership_response;
  bool remove_group;
  bool remove_group_response;
  bool remove_all_groups;
  bool add_group_if_identifying;
} uic_mqtt_dotdot_groups_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Groups/add_group is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_add_group_callback_set(const uic_mqtt_dotdot_groups_add_group_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/add_group_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_add_group_response_callback_set(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/view_group is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_view_group_callback_set(const uic_mqtt_dotdot_groups_view_group_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/view_group_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_view_group_response_callback_set(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/get_group_membership is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_get_group_membership_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/get_group_membership_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_get_group_membership_response_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/remove_group is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_remove_group_callback_set(const uic_mqtt_dotdot_groups_remove_group_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/remove_group_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_remove_group_response_callback_set(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/remove_all_groups is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_remove_all_groups_callback_set(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Groups/add_group_if_identifying is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_groups_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/groups/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_groups_write_attributes_callback(
  const uic_mqtt_dotdot_groups_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/groups/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_groups_force_read_attributes_callback(
  const uic_mqtt_dotdot_groups_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Groups/Attributes/NameSupport
 *
 * @param base_topic    topic prefix to publish, /name_support
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_groups_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Groups/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Groups/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_groups_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the scenes cluster
typedef sl_status_t (*uic_mqtt_dotdot_scenes_add_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid,

    uint16_t transition_time,

    SSceneName scene_name,

    SExtensionFieldSetList extension_field_sets
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_add_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_view_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_view_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid,

    uint16_t transition_time,

    SSceneName scene_name,

    SExtensionFieldSetList extension_field_sets
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_remove_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_remove_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_store_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_store_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_recall_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid,

    uint16_t transition_time
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_get_scene_membership_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint8_t capacity,

    SGroupId groupid,

    uint8_t scene_list
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid,

    uint16_t transition_time,

    SSceneName scene_name,

    SExtensionFieldSetList extension_field_sets
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SGroupId groupid,

    uint8_t sceneid
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId groupid,

    uint8_t sceneid,

    uint16_t transition_time,

    SSceneName scene_name,

    SExtensionFieldSetList extension_field_sets
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_copy_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t mode,

    SGroupId group_identifier_from,

    uint8_t scene_identifier_from,

    SGroupId group_identifier_to,

    uint8_t scene_identifier_to
);
typedef sl_status_t (*uic_mqtt_dotdot_scenes_copy_scene_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    SGroupId group_identifier_from,

    uint8_t scene_identifier_from
);

typedef struct {
  uint8_t scene_count;
  uint8_t current_scene;
  SGroupId current_group;
  bool scene_valid;
  uint8_t name_support;
  EUI64 last_configured_by;
} uic_mqtt_dotdot_scenes_state_t;

typedef struct {
  bool scene_count;
  bool current_scene;
  bool current_group;
  bool scene_valid;
  bool name_support;
  bool last_configured_by;
} uic_mqtt_dotdot_scenes_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_scenes_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_scenes_state_t,
    uic_mqtt_dotdot_scenes_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_scenes_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_scenes_updated_state_t
);

typedef struct {
  bool add_scene;
  bool add_scene_response;
  bool view_scene;
  bool view_scene_response;
  bool remove_scene;
  bool remove_scene_response;
  bool remove_all_scenes;
  bool remove_all_scenes_response;
  bool store_scene;
  bool store_scene_response;
  bool recall_scene;
  bool get_scene_membership;
  bool get_scene_membership_response;
  bool enhanced_add_scene;
  bool enhanced_add_scene_response;
  bool enhanced_view_scene;
  bool enhanced_view_scene_response;
  bool copy_scene;
  bool copy_scene_response;
} uic_mqtt_dotdot_scenes_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Scenes/add_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_add_scene_callback_set(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/add_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/view_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_view_scene_callback_set(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/view_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/remove_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_remove_scene_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/remove_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_remove_scene_response_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/remove_all_scenes is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_remove_all_scenes_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/remove_all_scenes_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/store_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_store_scene_callback_set(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/store_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_store_scene_response_callback_set(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/recall_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_recall_scene_callback_set(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/get_scene_membership is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_get_scene_membership_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/get_scene_membership_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/enhanced_add_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/enhanced_add_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/enhanced_view_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/enhanced_view_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/copy_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_copy_scene_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Scenes/copy_scene_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_scenes_copy_scene_response_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/scenes/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_scenes_write_attributes_callback(
  const uic_mqtt_dotdot_scenes_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/scenes/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_scenes_force_read_attributes_callback(
  const uic_mqtt_dotdot_scenes_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Scenes/Attributes/SceneCount
 *
 * @param base_topic    topic prefix to publish, /scene_count
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_scene_count_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Scenes/Attributes/CurrentScene
 *
 * @param base_topic    topic prefix to publish, /current_scene
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_current_scene_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Scenes/Attributes/CurrentGroup
 *
 * @param base_topic    topic prefix to publish, /current_group
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_current_group_publish(
  const char *base_topic,
  SGroupId value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Scenes/Attributes/SceneValid
 *
 * @param base_topic    topic prefix to publish, /scene_valid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_scene_valid_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Scenes/Attributes/NameSupport
 *
 * @param base_topic    topic prefix to publish, /name_support
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Scenes/Attributes/LastConfiguredBy
 *
 * @param base_topic    topic prefix to publish, /last_configured_by
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_scenes_last_configured_by_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Scenes/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Scenes/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_scenes_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the on_off cluster
typedef sl_status_t (*uic_mqtt_dotdot_on_off_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_on_off_on_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_on_off_toggle_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_on_off_off_with_effect_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    OffWithEffectEffectIdentifier effect_identifier,

    uint8_t effect_variant
);
typedef sl_status_t (*uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t on_off_control,

    uint16_t on_time,

    uint16_t off_wait_time
);

typedef struct {
  bool on_off;
  bool global_scene_control;
  uint16_t on_time;
  uint16_t off_wait_time;
  uint8_t start_up_on_off;
} uic_mqtt_dotdot_on_off_state_t;

typedef struct {
  bool on_off;
  bool global_scene_control;
  bool on_time;
  bool off_wait_time;
  bool start_up_on_off;
} uic_mqtt_dotdot_on_off_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_on_off_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_on_off_state_t,
    uic_mqtt_dotdot_on_off_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_on_off_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_on_off_updated_state_t
);

typedef struct {
  bool off;
  bool on;
  bool toggle;
  bool off_with_effect;
  bool on_with_recall_global_scene;
  bool on_with_timed_off;
} uic_mqtt_dotdot_on_off_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/OnOff/off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_off_callback_set(const uic_mqtt_dotdot_on_off_off_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OnOff/on is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_on_callback_set(const uic_mqtt_dotdot_on_off_on_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OnOff/toggle is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_toggle_callback_set(const uic_mqtt_dotdot_on_off_toggle_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OnOff/off_with_effect is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_off_with_effect_callback_set(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OnOff/on_with_recall_global_scene is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OnOff/on_with_timed_off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_on_off_on_with_timed_off_callback_set(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/on_off/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_on_off_write_attributes_callback(
  const uic_mqtt_dotdot_on_off_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/on_off/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_on_off_force_read_attributes_callback(
  const uic_mqtt_dotdot_on_off_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; OnOff/Attributes/OnOff
 *
 * @param base_topic    topic prefix to publish, /on_off
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_on_off_on_off_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OnOff/Attributes/GlobalSceneControl
 *
 * @param base_topic    topic prefix to publish, /global_scene_control
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_on_off_global_scene_control_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OnOff/Attributes/OnTime
 *
 * @param base_topic    topic prefix to publish, /on_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_on_off_on_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OnOff/Attributes/OffWaitTime
 *
 * @param base_topic    topic prefix to publish, /off_wait_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_on_off_off_wait_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OnOff/Attributes/StartUpOnOff
 *
 * @param base_topic    topic prefix to publish, /start_up_on_off
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_on_off_start_up_on_off_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the OnOff/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /OnOff/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_on_off_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the level cluster
typedef sl_status_t (*uic_mqtt_dotdot_level_move_to_level_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_move_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_step_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_stop_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_move_with_on_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_step_with_on_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_stop_with_on_off_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t frequency
);

typedef struct {
  uint8_t current_level;
  uint16_t remaining_time;
  uint8_t min_level;
  uint8_t max_level;
  uint16_t current_frequency;
  uint16_t min_frequency;
  uint16_t max_frequency;
  uint8_t options;
  uint16_t on_off_transition_time;
  uint8_t on_level;
  uint16_t on_transition_time;
  uint16_t off_transition_time;
  uint16_t default_move_rate;
  uint8_t start_up_current_level;
} uic_mqtt_dotdot_level_state_t;

typedef struct {
  bool current_level;
  bool remaining_time;
  bool min_level;
  bool max_level;
  bool current_frequency;
  bool min_frequency;
  bool max_frequency;
  bool options;
  bool on_off_transition_time;
  bool on_level;
  bool on_transition_time;
  bool off_transition_time;
  bool default_move_rate;
  bool start_up_current_level;
} uic_mqtt_dotdot_level_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_level_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_level_state_t,
    uic_mqtt_dotdot_level_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_level_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_level_updated_state_t
);

typedef struct {
  bool move_to_level;
  bool move;
  bool step;
  bool stop;
  bool move_to_level_with_on_off;
  bool move_with_on_off;
  bool step_with_on_off;
  bool stop_with_on_off;
  bool move_to_closest_frequency;
} uic_mqtt_dotdot_level_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Level/move_to_level is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_move_to_level_callback_set(const uic_mqtt_dotdot_level_move_to_level_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/move is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_move_callback_set(const uic_mqtt_dotdot_level_move_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/step is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_step_callback_set(const uic_mqtt_dotdot_level_step_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/stop is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_stop_callback_set(const uic_mqtt_dotdot_level_stop_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/move_to_level_with_on_off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/move_with_on_off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_move_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/step_with_on_off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_step_with_on_off_callback_set(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/stop_with_on_off is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_stop_with_on_off_callback_set(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Level/move_to_closest_frequency is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_level_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/level/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_level_write_attributes_callback(
  const uic_mqtt_dotdot_level_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/level/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_level_force_read_attributes_callback(
  const uic_mqtt_dotdot_level_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Level/Attributes/CurrentLevel
 *
 * @param base_topic    topic prefix to publish, /current_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/RemainingTime
 *
 * @param base_topic    topic prefix to publish, /remaining_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/MinLevel
 *
 * @param base_topic    topic prefix to publish, /min_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/MaxLevel
 *
 * @param base_topic    topic prefix to publish, /max_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/CurrentFrequency
 *
 * @param base_topic    topic prefix to publish, /current_frequency
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_current_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/MinFrequency
 *
 * @param base_topic    topic prefix to publish, /min_frequency
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_min_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/MaxFrequency
 *
 * @param base_topic    topic prefix to publish, /max_frequency
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_max_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/Options
 *
 * @param base_topic    topic prefix to publish, /options
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/OnOffTransitionTime
 *
 * @param base_topic    topic prefix to publish, /on_off_transition_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_on_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/OnLevel
 *
 * @param base_topic    topic prefix to publish, /on_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/OnTransitionTime
 *
 * @param base_topic    topic prefix to publish, /on_transition_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_on_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/OffTransitionTime
 *
 * @param base_topic    topic prefix to publish, /off_transition_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/DefaultMoveRate
 *
 * @param base_topic    topic prefix to publish, /default_move_rate
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_default_move_rate_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Level/Attributes/StartUpCurrentLevel
 *
 * @param base_topic    topic prefix to publish, /start_up_current_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_level_start_up_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Level/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Level/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_level_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the alarms cluster
typedef sl_status_t (*uic_mqtt_dotdot_alarms_reset_alarm_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t alarm_code,

    clusterId cluster_identifier
);
typedef sl_status_t (*uic_mqtt_dotdot_alarms_alarm_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t alarm_code,

    clusterId cluster_identifier
);
typedef sl_status_t (*uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_alarms_get_alarm_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint8_t alarm_code,

    clusterId cluster_identifier,

    uint32_t time_stamp
);
typedef sl_status_t (*uic_mqtt_dotdot_alarms_get_alarm_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);

typedef struct {
  uint16_t alarm_count;
} uic_mqtt_dotdot_alarms_state_t;

typedef struct {
  bool alarm_count;
} uic_mqtt_dotdot_alarms_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_alarms_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_alarms_state_t,
    uic_mqtt_dotdot_alarms_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_alarms_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_alarms_updated_state_t
);

typedef struct {
  bool reset_alarm;
  bool alarm;
  bool reset_all_alarms;
  bool get_alarm_response;
  bool get_alarm;
  bool reset_alarm_log;
} uic_mqtt_dotdot_alarms_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Alarms/reset_alarm is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_reset_alarm_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Alarms/alarm is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_alarm_callback_set(const uic_mqtt_dotdot_alarms_alarm_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Alarms/reset_all_alarms is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_reset_all_alarms_callback_set(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Alarms/get_alarm_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_get_alarm_response_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Alarms/get_alarm is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_get_alarm_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Alarms/reset_alarm_log is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_alarms_reset_alarm_log_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/alarms/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_alarms_write_attributes_callback(
  const uic_mqtt_dotdot_alarms_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/alarms/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_alarms_force_read_attributes_callback(
  const uic_mqtt_dotdot_alarms_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Alarms/Attributes/AlarmCount
 *
 * @param base_topic    topic prefix to publish, /alarm_count
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_alarms_alarm_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Alarms/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Alarms/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_alarms_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the time cluster

typedef struct {
  UTC time;
  uint8_t time_status;
  int32_t time_zone;
  uint32_t dst_start;
  uint32_t dst_end;
  int32_t dst_shift;
  uint32_t standard_time;
  uint32_t local_time;
  UTC last_set_time;
  UTC valid_until_time;
} uic_mqtt_dotdot_time_state_t;

typedef struct {
  bool time;
  bool time_status;
  bool time_zone;
  bool dst_start;
  bool dst_end;
  bool dst_shift;
  bool standard_time;
  bool local_time;
  bool last_set_time;
  bool valid_until_time;
} uic_mqtt_dotdot_time_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_time_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_time_state_t,
    uic_mqtt_dotdot_time_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_time_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_time_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_time_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/time/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_time_write_attributes_callback(
  const uic_mqtt_dotdot_time_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/time/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_time_force_read_attributes_callback(
  const uic_mqtt_dotdot_time_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Time/Attributes/Time
 *
 * @param base_topic    topic prefix to publish, /time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/TimeStatus
 *
 * @param base_topic    topic prefix to publish, /time_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_time_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/TimeZone
 *
 * @param base_topic    topic prefix to publish, /time_zone
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_time_zone_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/DstStart
 *
 * @param base_topic    topic prefix to publish, /dst_start
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_dst_start_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/DstEnd
 *
 * @param base_topic    topic prefix to publish, /dst_end
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_dst_end_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/DstShift
 *
 * @param base_topic    topic prefix to publish, /dst_shift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_dst_shift_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/StandardTime
 *
 * @param base_topic    topic prefix to publish, /standard_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_standard_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/LocalTime
 *
 * @param base_topic    topic prefix to publish, /local_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_local_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/LastSetTime
 *
 * @param base_topic    topic prefix to publish, /last_set_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_last_set_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Time/Attributes/ValidUntilTime
 *
 * @param base_topic    topic prefix to publish, /valid_until_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_time_valid_until_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Time/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Time/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_time_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the ota_upgrade cluster
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    ImageNotifyPayloadType payload_type,

    uint8_t query_jitter,

    uint16_t manufacturer_code,

    uint16_t image_type,

    uint32_t new_file_version
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t field_control,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t current_file_version,

    uint16_t hardware_version
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version,

    uint32_t image_size
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t field_control,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version,

    uint32_t file_offset,

    uint8_t maximum_data_size,

    EUI64 request_node_address,

    uint16_t minimum_block_period
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t field_control,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version,

    uint32_t file_offset,

    uint8_t maximum_data_size,

    uint16_t page_size,

    uint16_t response_spacing,

    EUI64 request_node_address
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version,

    uint32_t file_offset,

    const char* image_data,

    uint32_t current_time,

    uint32_t request_time,

    uint16_t minimum_block_period
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t manufacturer_code,

    OTAImageType image_type,

    uint32_t file_version,

    UTC current_time,

    UTC upgrade_time
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    EUI64 request_node_address,

    uint16_t manufacturer_code,

    OTADeviceSpecificImageType image_type,

    uint32_t file_version,

    uint16_t current_zigbee_stack_version
);
typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status,

    uint16_t manufacturer_code,

    OTADeviceSpecificImageType image_type,

    uint32_t file_version,

    uint32_t image_size
);

typedef struct {
  EUI64 upgrade_serverid;
  uint32_t file_offset;
  uint32_t current_file_version;
  uint16_t current_zig_bee_stack_version;
  uint32_t downloaded_file_version;
  uint16_t downloaded_zig_bee_stack_version;
  uint8_t image_upgrade_status;
  uint16_t manufacturerid;
  uint16_t image_typeid;
  uint16_t minimum_block_period;
  uint32_t image_stamp;
  uint8_t upgrade_activation_policy;
  uint8_t upgrade_timeout_policy;
} uic_mqtt_dotdot_ota_upgrade_state_t;

typedef struct {
  bool upgrade_serverid;
  bool file_offset;
  bool current_file_version;
  bool current_zig_bee_stack_version;
  bool downloaded_file_version;
  bool downloaded_zig_bee_stack_version;
  bool image_upgrade_status;
  bool manufacturerid;
  bool image_typeid;
  bool minimum_block_period;
  bool image_stamp;
  bool upgrade_activation_policy;
  bool upgrade_timeout_policy;
} uic_mqtt_dotdot_ota_upgrade_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ota_upgrade_state_t,
    uic_mqtt_dotdot_ota_upgrade_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ota_upgrade_updated_state_t
);

typedef struct {
  bool image_notify;
  bool query_next_image_request;
  bool query_next_image_response;
  bool image_block_request;
  bool image_page_request;
  bool image_block_response;
  bool upgrade_end_request;
  bool upgrade_end_response;
  bool query_device_specific_file_request;
  bool query_device_specific_file_response;
} uic_mqtt_dotdot_ota_upgrade_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/OTAUpgrade/image_notify is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_image_notify_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_notify_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/query_next_image_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/query_next_image_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_next_image_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/image_block_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/image_page_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_page_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/image_block_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_image_block_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/upgrade_end_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/upgrade_end_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_upgrade_end_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/query_device_specific_file_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/OTAUpgrade/query_device_specific_file_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_set(const uic_mqtt_dotdot_ota_upgrade_query_device_specific_file_response_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/ota_upgrade/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ota_upgrade_write_attributes_callback(
  const uic_mqtt_dotdot_ota_upgrade_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/ota_upgrade/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ota_upgrade_force_read_attributes_callback(
  const uic_mqtt_dotdot_ota_upgrade_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/UpgradeServerID
 *
 * @param base_topic    topic prefix to publish, /upgrade_serverid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_serverid_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/FileOffset
 *
 * @param base_topic    topic prefix to publish, /file_offset
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_file_offset_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/CurrentFileVersion
 *
 * @param base_topic    topic prefix to publish, /current_file_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_current_file_version_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/CurrentZigBeeStackVersion
 *
 * @param base_topic    topic prefix to publish, /current_zig_bee_stack_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_current_zig_bee_stack_version_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/DownloadedFileVersion
 *
 * @param base_topic    topic prefix to publish, /downloaded_file_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_downloaded_file_version_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/DownloadedZigBeeStackVersion
 *
 * @param base_topic    topic prefix to publish, /downloaded_zig_bee_stack_version
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_downloaded_zig_bee_stack_version_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/ImageUpgradeStatus
 *
 * @param base_topic    topic prefix to publish, /image_upgrade_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_upgrade_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/ManufacturerID
 *
 * @param base_topic    topic prefix to publish, /manufacturerid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_manufacturerid_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/ImageTypeID
 *
 * @param base_topic    topic prefix to publish, /image_typeid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_typeid_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/MinimumBlockPeriod
 *
 * @param base_topic    topic prefix to publish, /minimum_block_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_minimum_block_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/ImageStamp
 *
 * @param base_topic    topic prefix to publish, /image_stamp
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_image_stamp_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/UpgradeActivationPolicy
 *
 * @param base_topic    topic prefix to publish, /upgrade_activation_policy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_activation_policy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OTAUpgrade/Attributes/UpgradeTimeoutPolicy
 *
 * @param base_topic    topic prefix to publish, /upgrade_timeout_policy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ota_upgrade_upgrade_timeout_policy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the OTAUpgrade/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /OTAUpgrade/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_ota_upgrade_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the poll_control cluster
typedef sl_status_t (*uic_mqtt_dotdot_poll_control_check_in_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_poll_control_check_in_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    bool start_fast_polling,

    uint16_t fast_poll_timeout
);
typedef sl_status_t (*uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint32_t new_long_poll_interval
);
typedef sl_status_t (*uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t new_short_poll_interval
);

typedef struct {
  uint32_t check_in_interval;
  uint32_t long_poll_interval;
  uint16_t short_poll_interval;
  uint16_t fast_poll_timeout;
  uint32_t check_in_interval_min;
  uint32_t long_poll_interval_min;
  uint16_t fast_poll_timeout_max;
} uic_mqtt_dotdot_poll_control_state_t;

typedef struct {
  bool check_in_interval;
  bool long_poll_interval;
  bool short_poll_interval;
  bool fast_poll_timeout;
  bool check_in_interval_min;
  bool long_poll_interval_min;
  bool fast_poll_timeout_max;
} uic_mqtt_dotdot_poll_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_poll_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_poll_control_state_t,
    uic_mqtt_dotdot_poll_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_poll_control_updated_state_t
);

typedef struct {
  bool check_in;
  bool check_in_response;
  bool fast_poll_stop;
  bool set_long_poll_interval;
  bool set_short_poll_interval;
} uic_mqtt_dotdot_poll_control_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/PollControl/check_in is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_poll_control_check_in_callback_set(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback);

/**
 * Setup callback to be called when a
 * +/PollControl/check_in_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_poll_control_check_in_response_callback_set(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/PollControl/fast_poll_stop is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_set(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback);

/**
 * Setup callback to be called when a
 * +/PollControl/set_long_poll_interval is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback);

/**
 * Setup callback to be called when a
 * +/PollControl/set_short_poll_interval is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/poll_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
  const uic_mqtt_dotdot_poll_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/poll_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_poll_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; PollControl/Attributes/CheckInInterval
 *
 * @param base_topic    topic prefix to publish, /check_in_interval
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/LongPollInterval
 *
 * @param base_topic    topic prefix to publish, /long_poll_interval
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/ShortPollInterval
 *
 * @param base_topic    topic prefix to publish, /short_poll_interval
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/FastPollTimeout
 *
 * @param base_topic    topic prefix to publish, /fast_poll_timeout
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/CheckInIntervalMin
 *
 * @param base_topic    topic prefix to publish, /check_in_interval_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/LongPollIntervalMin
 *
 * @param base_topic    topic prefix to publish, /long_poll_interval_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PollControl/Attributes/FastPollTimeoutMax
 *
 * @param base_topic    topic prefix to publish, /fast_poll_timeout_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the PollControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /PollControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_poll_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the shade_configuration cluster

typedef struct {
  uint16_t physical_closed_limit;
  uint8_t motor_step_size;
  uint8_t status;
  uint16_t closed_limit;
  uint8_t mode;
} uic_mqtt_dotdot_shade_configuration_state_t;

typedef struct {
  bool physical_closed_limit;
  bool motor_step_size;
  bool status;
  bool closed_limit;
  bool mode;
} uic_mqtt_dotdot_shade_configuration_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_shade_configuration_state_t,
    uic_mqtt_dotdot_shade_configuration_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_shade_configuration_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_shade_configuration_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/shade_configuration/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_shade_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/shade_configuration/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_shade_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; ShadeConfiguration/Attributes/PhysicalClosedLimit
 *
 * @param base_topic    topic prefix to publish, /physical_closed_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ShadeConfiguration/Attributes/MotorStepSize
 *
 * @param base_topic    topic prefix to publish, /motor_step_size
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ShadeConfiguration/Attributes/Status
 *
 * @param base_topic    topic prefix to publish, /status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_shade_configuration_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ShadeConfiguration/Attributes/ClosedLimit
 *
 * @param base_topic    topic prefix to publish, /closed_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ShadeConfiguration/Attributes/Mode
 *
 * @param base_topic    topic prefix to publish, /mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_shade_configuration_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the ShadeConfiguration/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /ShadeConfiguration/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_shade_configuration_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the door_lock cluster
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_lock_door_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    const char* pin_orrfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_lock_door_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_unlock_door_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    const char* pin_orrfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_toggle_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    const char* pin_orrfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_toggle_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t timeout_in_seconds,

    const char* pin_orrfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    zclStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_log_record_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t log_index
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t log_entryid,

    uint32_t timestamp,

    GetLogRecordResponseEventType event_type,

    DrlkOperEventSource source_operation_event,

    uint8_t eventid_or_alarm_code,

    uint16_t userid,

    const char* pin
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_setpin_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPINUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* pin
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkSetCodeStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_getpin_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPINUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t userid,

    DrlkUserStatus user_status,

    DrlkUserType user_type,

    const char* code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clearpin_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPINUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_user_status_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkTotalUserID userid,

    DrlkSettableUserStatus user_status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_user_status_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t userid,

    DrlkUserStatus user_status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint8_t days_mask,

    uint8_t start_hour,

    uint8_t start_minute,

    uint8_t end_hour,

    uint8_t end_minute
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t scheduleid,

    uint16_t userid,

    zclStatus status,

    uint8_t days_mask,

    uint8_t start_hour,

    uint8_t start_minute,

    uint8_t end_hour,

    uint8_t end_minute
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint32_t local_start_time,

    uint32_t local_end_time
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t scheduleid,

    uint16_t userid,

    zclStatus status,

    uint32_t local_start_time,

    uint32_t local_end_time
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkHolidayScheduleID holiday_scheduleid,

    uint32_t local_start_time,

    uint32_t local_end_time,

    DrlkOperMode operating_mode_during_holiday
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkHolidayScheduleID holiday_scheduleid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t holiday_scheduleid,

    zclStatus status,

    uint32_t local_start_time,

    uint32_t local_end_time,

    DrlkOperMode operating_mode_during_holiday
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkHolidayScheduleID holiday_scheduleid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_user_type_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkTotalUserID userid,

    DrlkUserType user_type
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_user_type_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkTotalUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t userid,

    DrlkUserType user_type
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_setrfid_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkRFIDUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* rfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkSetCodeStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_getrfid_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkRFIDUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t userid,

    DrlkUserStatus user_status,

    DrlkUserType user_type,

    const char* rfid_code
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkRFIDUserID userid
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkPassFailStatus status
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    DrlkOperEventSource operation_event_source,

    OperatingEventNotificationOperationEventCode operation_event_code,

    uint16_t userid,

    const char* pin,

    uint32_t local_time,

    const char* data
);
typedef sl_status_t (*uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    ProgrammingEventNotificationProgramEventSource program_event_source,

    ProgrammingEventNotificationProgramEventCode program_event_code,

    uint16_t userid,

    const char* pin,

    DrlkUserType user_type,

    DrlkUserStatus user_status,

    uint32_t local_time,

    const char* data
);

typedef struct {
  uint8_t lock_state;
  uint8_t lock_type;
  bool actuator_enabled;
  uint8_t door_state;
  uint32_t door_open_events;
  uint32_t door_closed_events;
  uint16_t open_period;
  uint16_t number_of_log_records_supported;
  uint16_t number_of_total_users_supported;
  uint16_t number_ofpin_users_supported;
  uint16_t number_ofrfid_users_supported;
  uint8_t number_of_week_day_schedules_supported_per_user;
  uint8_t number_of_year_day_schedules_supported_per_user;
  uint8_t number_of_holiday_schedules_supported;
  uint8_t maxpin_code_length;
  uint8_t minpin_code_length;
  uint8_t maxrfid_code_length;
  uint8_t minrfid_code_length;
  bool enable_logging;
  const char* language;
  uint8_t led_settings;
  uint32_t auto_relock_time;
  uint8_t sound_volume;
  uint8_t operating_mode;
  uint16_t supported_operating_modes;
  uint16_t default_configuration_register;
  bool enable_local_programming;
  bool enable_one_touch_locking;
  bool enable_inside_statusled;
  bool enable_privacy_mode_button;
  uint8_t wrong_code_entry_limit;
  uint8_t user_code_temporary_disable_time;
  bool sendpin_over_the_air;
  bool requirepi_nforrf_operation;
  uint8_t security_level;
  uint16_t alarm_mask;
  uint16_t keypad_operation_event_mask;
  uint16_t rf_operation_event_mask;
  uint16_t manual_operation_event_mask;
  uint16_t rfid_operation_event_mask;
  uint16_t keypad_programming_event_mask;
  uint16_t rf_programming_event_mask;
  uint16_t rfid_programming_event_mask;
} uic_mqtt_dotdot_door_lock_state_t;

typedef struct {
  bool lock_state;
  bool lock_type;
  bool actuator_enabled;
  bool door_state;
  bool door_open_events;
  bool door_closed_events;
  bool open_period;
  bool number_of_log_records_supported;
  bool number_of_total_users_supported;
  bool number_ofpin_users_supported;
  bool number_ofrfid_users_supported;
  bool number_of_week_day_schedules_supported_per_user;
  bool number_of_year_day_schedules_supported_per_user;
  bool number_of_holiday_schedules_supported;
  bool maxpin_code_length;
  bool minpin_code_length;
  bool maxrfid_code_length;
  bool minrfid_code_length;
  bool enable_logging;
  bool language;
  bool led_settings;
  bool auto_relock_time;
  bool sound_volume;
  bool operating_mode;
  bool supported_operating_modes;
  bool default_configuration_register;
  bool enable_local_programming;
  bool enable_one_touch_locking;
  bool enable_inside_statusled;
  bool enable_privacy_mode_button;
  bool wrong_code_entry_limit;
  bool user_code_temporary_disable_time;
  bool sendpin_over_the_air;
  bool requirepi_nforrf_operation;
  bool security_level;
  bool alarm_mask;
  bool keypad_operation_event_mask;
  bool rf_operation_event_mask;
  bool manual_operation_event_mask;
  bool rfid_operation_event_mask;
  bool keypad_programming_event_mask;
  bool rf_programming_event_mask;
  bool rfid_programming_event_mask;
} uic_mqtt_dotdot_door_lock_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_door_lock_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_door_lock_state_t,
    uic_mqtt_dotdot_door_lock_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_door_lock_updated_state_t
);

typedef struct {
  bool lock_door;
  bool lock_door_response;
  bool unlock_door;
  bool unlock_door_response;
  bool toggle;
  bool toggle_response;
  bool unlock_with_timeout;
  bool unlock_with_timeout_response;
  bool get_log_record;
  bool get_log_record_response;
  bool setpin_code;
  bool setpin_code_response;
  bool getpin_code;
  bool getpin_code_response;
  bool clearpin_code;
  bool clearpin_code_response;
  bool clear_allpin_codes;
  bool clear_allpin_codes_response;
  bool set_user_status;
  bool set_user_status_response;
  bool get_user_status;
  bool get_user_status_response;
  bool set_weekday_schedule;
  bool set_weekday_schedule_response;
  bool get_weekday_schedule;
  bool get_weekday_schedule_response;
  bool clear_weekday_schedule;
  bool clear_weekday_schedule_response;
  bool set_year_day_schedule;
  bool set_year_day_schedule_response;
  bool get_year_day_schedule;
  bool get_year_day_schedule_response;
  bool clear_year_day_schedule;
  bool clear_year_day_schedule_response;
  bool set_holiday_schedule;
  bool set_holiday_schedule_response;
  bool get_holiday_schedule;
  bool get_holiday_schedule_response;
  bool clear_holiday_schedule;
  bool clear_holiday_schedule_response;
  bool set_user_type;
  bool set_user_type_response;
  bool get_user_type;
  bool get_user_type_response;
  bool setrfid_code;
  bool setrfid_code_response;
  bool getrfid_code;
  bool getrfid_code_response;
  bool clearrfid_code;
  bool clearrfid_code_response;
  bool clear_allrfid_codes;
  bool clear_allrfid_codes_response;
  bool operating_event_notification;
  bool programming_event_notification;
} uic_mqtt_dotdot_door_lock_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/DoorLock/lock_door is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_lock_door_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/lock_door_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_lock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/unlock_door is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_unlock_door_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/unlock_door_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_unlock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/toggle is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_toggle_callback_set(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/toggle_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_toggle_response_callback_set(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/unlock_with_timeout is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/unlock_with_timeout_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_log_record is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_log_record_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_log_record_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_log_record_response_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/setpin_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_setpin_code_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/setpin_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_setpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setpin_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/getpin_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_getpin_code_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/getpin_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_getpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getpin_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clearpin_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clearpin_code_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clearpin_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearpin_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_allpin_codes is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_allpin_codes_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allpin_codes_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_user_status is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_user_status_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_user_status_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_user_status is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_user_status_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_user_status_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_weekday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_weekday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_weekday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_weekday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_weekday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_weekday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_year_day_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_year_day_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_year_day_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_year_day_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_year_day_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_year_day_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_holiday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_holiday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_holiday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_holiday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_holiday_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_holiday_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_user_type is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_user_type_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/set_user_type_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_set_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_user_type is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_user_type_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/get_user_type_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_get_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/setrfid_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_setrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/setrfid_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_setrfid_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/getrfid_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_getrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/getrfid_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_getrfid_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clearrfid_code is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clearrfid_code_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clearrfid_code_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clearrfid_code_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_allrfid_codes is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/clear_allrfid_codes_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_allrfid_codes_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/operating_event_notification is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_operating_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback);

/**
 * Setup callback to be called when a
 * +/DoorLock/programming_event_notification is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_door_lock_programming_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/door_lock/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
  const uic_mqtt_dotdot_door_lock_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/door_lock/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_door_lock_force_read_attributes_callback(
  const uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/LockState
 *
 * @param base_topic    topic prefix to publish, /lock_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_lock_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/LockType
 *
 * @param base_topic    topic prefix to publish, /lock_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_lock_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/ActuatorEnabled
 *
 * @param base_topic    topic prefix to publish, /actuator_enabled
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/DoorState
 *
 * @param base_topic    topic prefix to publish, /door_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_door_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/DoorOpenEvents
 *
 * @param base_topic    topic prefix to publish, /door_open_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_door_open_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/DoorClosedEvents
 *
 * @param base_topic    topic prefix to publish, /door_closed_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_door_closed_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/OpenPeriod
 *
 * @param base_topic    topic prefix to publish, /open_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfLogRecordsSupported
 *
 * @param base_topic    topic prefix to publish, /number_of_log_records_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfTotalUsersSupported
 *
 * @param base_topic    topic prefix to publish, /number_of_total_users_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfPINUsersSupported
 *
 * @param base_topic    topic prefix to publish, /number_ofpin_users_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_ofpin_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfRFIDUsersSupported
 *
 * @param base_topic    topic prefix to publish, /number_ofrfid_users_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_ofrfid_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser
 *
 * @param base_topic    topic prefix to publish, /number_of_week_day_schedules_supported_per_user
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser
 *
 * @param base_topic    topic prefix to publish, /number_of_year_day_schedules_supported_per_user
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/NumberOfHolidaySchedulesSupported
 *
 * @param base_topic    topic prefix to publish, /number_of_holiday_schedules_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/MaxPINCodeLength
 *
 * @param base_topic    topic prefix to publish, /maxpin_code_length
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_maxpin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/MinPINCodeLength
 *
 * @param base_topic    topic prefix to publish, /minpin_code_length
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_minpin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/MaxRFIDCodeLength
 *
 * @param base_topic    topic prefix to publish, /maxrfid_code_length
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_maxrfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/MinRFIDCodeLength
 *
 * @param base_topic    topic prefix to publish, /minrfid_code_length
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_minrfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/EnableLogging
 *
 * @param base_topic    topic prefix to publish, /enable_logging
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_enable_logging_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/Language
 *
 * @param base_topic    topic prefix to publish, /language
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_language_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/LEDSettings
 *
 * @param base_topic    topic prefix to publish, /led_settings
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_led_settings_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/AutoRelockTime
 *
 * @param base_topic    topic prefix to publish, /auto_relock_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/SoundVolume
 *
 * @param base_topic    topic prefix to publish, /sound_volume
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_sound_volume_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/OperatingMode
 *
 * @param base_topic    topic prefix to publish, /operating_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_operating_mode_publish(
  const char *base_topic,
  DrlkOperMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/SupportedOperatingModes
 *
 * @param base_topic    topic prefix to publish, /supported_operating_modes
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/DefaultConfigurationRegister
 *
 * @param base_topic    topic prefix to publish, /default_configuration_register
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/EnableLocalProgramming
 *
 * @param base_topic    topic prefix to publish, /enable_local_programming
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/EnableOneTouchLocking
 *
 * @param base_topic    topic prefix to publish, /enable_one_touch_locking
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/EnableInsideStatusLED
 *
 * @param base_topic    topic prefix to publish, /enable_inside_statusled
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/EnablePrivacyModeButton
 *
 * @param base_topic    topic prefix to publish, /enable_privacy_mode_button
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/WrongCodeEntryLimit
 *
 * @param base_topic    topic prefix to publish, /wrong_code_entry_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/UserCodeTemporaryDisableTime
 *
 * @param base_topic    topic prefix to publish, /user_code_temporary_disable_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/SendPINOverTheAir
 *
 * @param base_topic    topic prefix to publish, /sendpin_over_the_air
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_sendpin_over_the_air_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/RequirePINforRFOperation
 *
 * @param base_topic    topic prefix to publish, /requirepi_nforrf_operation
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_requirepi_nforrf_operation_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/SecurityLevel
 *
 * @param base_topic    topic prefix to publish, /security_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_security_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/AlarmMask
 *
 * @param base_topic    topic prefix to publish, /alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/KeypadOperationEventMask
 *
 * @param base_topic    topic prefix to publish, /keypad_operation_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/RFOperationEventMask
 *
 * @param base_topic    topic prefix to publish, /rf_operation_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/ManualOperationEventMask
 *
 * @param base_topic    topic prefix to publish, /manual_operation_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/RFIDOperationEventMask
 *
 * @param base_topic    topic prefix to publish, /rfid_operation_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/KeypadProgrammingEventMask
 *
 * @param base_topic    topic prefix to publish, /keypad_programming_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/RFProgrammingEventMask
 *
 * @param base_topic    topic prefix to publish, /rf_programming_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DoorLock/Attributes/RFIDProgrammingEventMask
 *
 * @param base_topic    topic prefix to publish, /rfid_programming_event_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the DoorLock/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /DoorLock/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_door_lock_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the window_covering cluster
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_up_or_open_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_down_or_close_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_stop_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t lift_value
);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t percentage_lift_value
);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t tilt_value
);
typedef sl_status_t (*uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t percentage_tilt_value
);

typedef struct {
  uint8_t window_covering_type;
  uint16_t physical_closed_limit_lift;
  uint16_t physical_closed_limit_tilt;
  uint16_t current_position_lift;
  uint16_t current_position_tilt;
  uint16_t number_of_actuations_lift;
  uint16_t number_of_actuations_tilt;
  uint8_t config_or_status;
  uint8_t current_position_lift_percentage;
  uint8_t current_position_tilt_percentage;
  uint16_t installed_open_limit_lift;
  uint16_t installed_closed_limit_lift;
  uint16_t installed_open_limit_tilt;
  uint16_t installed_closed_limit_tilt;
  uint16_t velocity_lift;
  uint16_t acceleration_time_lift;
  uint16_t deceleration_time_lift;
  uint8_t mode;
  const char* intermediate_setpoints_lift;
  const char* intermediate_setpoints_tilt;
} uic_mqtt_dotdot_window_covering_state_t;

typedef struct {
  bool window_covering_type;
  bool physical_closed_limit_lift;
  bool physical_closed_limit_tilt;
  bool current_position_lift;
  bool current_position_tilt;
  bool number_of_actuations_lift;
  bool number_of_actuations_tilt;
  bool config_or_status;
  bool current_position_lift_percentage;
  bool current_position_tilt_percentage;
  bool installed_open_limit_lift;
  bool installed_closed_limit_lift;
  bool installed_open_limit_tilt;
  bool installed_closed_limit_tilt;
  bool velocity_lift;
  bool acceleration_time_lift;
  bool deceleration_time_lift;
  bool mode;
  bool intermediate_setpoints_lift;
  bool intermediate_setpoints_tilt;
} uic_mqtt_dotdot_window_covering_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_window_covering_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_window_covering_state_t,
    uic_mqtt_dotdot_window_covering_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_window_covering_updated_state_t
);

typedef struct {
  bool up_or_open;
  bool down_or_close;
  bool stop;
  bool go_to_lift_value;
  bool go_to_lift_percentage;
  bool go_to_tilt_value;
  bool go_to_tilt_percentage;
} uic_mqtt_dotdot_window_covering_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/WindowCovering/up_or_open is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_up_or_open_callback_set(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/down_or_close is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_down_or_close_callback_set(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/stop is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_stop_callback_set(const uic_mqtt_dotdot_window_covering_stop_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/go_to_lift_value is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/go_to_lift_percentage is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/go_to_tilt_value is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback);

/**
 * Setup callback to be called when a
 * +/WindowCovering/go_to_tilt_percentage is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/window_covering/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_window_covering_write_attributes_callback(
  const uic_mqtt_dotdot_window_covering_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/window_covering/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_window_covering_force_read_attributes_callback(
  const uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/WindowCoveringType
 *
 * @param base_topic    topic prefix to publish, /window_covering_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_window_covering_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/PhysicalClosedLimitLift
 *
 * @param base_topic    topic prefix to publish, /physical_closed_limit_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/PhysicalClosedLimitTilt
 *
 * @param base_topic    topic prefix to publish, /physical_closed_limit_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/CurrentPositionLift
 *
 * @param base_topic    topic prefix to publish, /current_position_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/CurrentPositionTilt
 *
 * @param base_topic    topic prefix to publish, /current_position_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/NumberOfActuationsLift
 *
 * @param base_topic    topic prefix to publish, /number_of_actuations_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/NumberOfActuationsTilt
 *
 * @param base_topic    topic prefix to publish, /number_of_actuations_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/ConfigOrStatus
 *
 * @param base_topic    topic prefix to publish, /config_or_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_config_or_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/CurrentPositionLiftPercentage
 *
 * @param base_topic    topic prefix to publish, /current_position_lift_percentage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/CurrentPositionTiltPercentage
 *
 * @param base_topic    topic prefix to publish, /current_position_tilt_percentage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/InstalledOpenLimitLift
 *
 * @param base_topic    topic prefix to publish, /installed_open_limit_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/InstalledClosedLimitLift
 *
 * @param base_topic    topic prefix to publish, /installed_closed_limit_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/InstalledOpenLimitTilt
 *
 * @param base_topic    topic prefix to publish, /installed_open_limit_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/InstalledClosedLimitTilt
 *
 * @param base_topic    topic prefix to publish, /installed_closed_limit_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/VelocityLift
 *
 * @param base_topic    topic prefix to publish, /velocity_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_velocity_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/AccelerationTimeLift
 *
 * @param base_topic    topic prefix to publish, /acceleration_time_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/DecelerationTimeLift
 *
 * @param base_topic    topic prefix to publish, /deceleration_time_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/Mode
 *
 * @param base_topic    topic prefix to publish, /mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/IntermediateSetpointsLift
 *
 * @param base_topic    topic prefix to publish, /intermediate_setpoints_lift
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindowCovering/Attributes/IntermediateSetpointsTilt
 *
 * @param base_topic    topic prefix to publish, /intermediate_setpoints_tilt
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the WindowCovering/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /WindowCovering/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_window_covering_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the barrier_control cluster
typedef sl_status_t (*uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t percent_open
);
typedef sl_status_t (*uic_mqtt_dotdot_barrier_control_stop_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);

typedef struct {
  uint8_t moving_state;
  uint16_t safety_status;
  uint8_t capabilities;
  uint16_t open_events;
  uint16_t close_events;
  uint16_t command_open_events;
  uint16_t command_close_events;
  uint16_t open_period;
  uint16_t close_period;
  uint8_t barrier_position;
} uic_mqtt_dotdot_barrier_control_state_t;

typedef struct {
  bool moving_state;
  bool safety_status;
  bool capabilities;
  bool open_events;
  bool close_events;
  bool command_open_events;
  bool command_close_events;
  bool open_period;
  bool close_period;
  bool barrier_position;
} uic_mqtt_dotdot_barrier_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_barrier_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_barrier_control_state_t,
    uic_mqtt_dotdot_barrier_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_barrier_control_updated_state_t
);

typedef struct {
  bool go_to_percent;
  bool stop;
} uic_mqtt_dotdot_barrier_control_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/BarrierControl/go_to_percent is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_barrier_control_go_to_percent_callback_set(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback);

/**
 * Setup callback to be called when a
 * +/BarrierControl/stop is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_barrier_control_stop_callback_set(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/barrier_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_barrier_control_write_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/barrier_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_barrier_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/MovingState
 *
 * @param base_topic    topic prefix to publish, /moving_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_moving_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/SafetyStatus
 *
 * @param base_topic    topic prefix to publish, /safety_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_safety_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/Capabilities
 *
 * @param base_topic    topic prefix to publish, /capabilities
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_capabilities_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/OpenEvents
 *
 * @param base_topic    topic prefix to publish, /open_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/CloseEvents
 *
 * @param base_topic    topic prefix to publish, /close_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/CommandOpenEvents
 *
 * @param base_topic    topic prefix to publish, /command_open_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_command_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/CommandCloseEvents
 *
 * @param base_topic    topic prefix to publish, /command_close_events
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_command_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/OpenPeriod
 *
 * @param base_topic    topic prefix to publish, /open_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/ClosePeriod
 *
 * @param base_topic    topic prefix to publish, /close_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_close_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BarrierControl/Attributes/BarrierPosition
 *
 * @param base_topic    topic prefix to publish, /barrier_position
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_barrier_control_barrier_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the BarrierControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /BarrierControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_barrier_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the pump_configuration_and_control cluster

typedef struct {
  int16_t max_pressure;
  uint16_t max_speed;
  uint16_t max_flow;
  int16_t min_const_pressure;
  int16_t max_const_pressure;
  int16_t min_comp_pressure;
  int16_t max_comp_pressure;
  uint16_t min_const_speed;
  uint16_t max_const_speed;
  uint16_t min_const_flow;
  uint16_t max_const_flow;
  int16_t min_const_temp;
  int16_t max_const_temp;
  uint16_t pump_status;
  uint8_t effective_operation_mode;
  uint8_t effective_control_mode;
  int16_t capacity;
  uint16_t speed;
  uint32_t lifetime_running_hours;
  uint32_t power;
  uint32_t lifetime_energy_consumed;
  uint8_t operation_mode;
  uint8_t control_mode;
  uint16_t alarm_mask;
} uic_mqtt_dotdot_pump_configuration_and_control_state_t;

typedef struct {
  bool max_pressure;
  bool max_speed;
  bool max_flow;
  bool min_const_pressure;
  bool max_const_pressure;
  bool min_comp_pressure;
  bool max_comp_pressure;
  bool min_const_speed;
  bool max_const_speed;
  bool min_const_flow;
  bool max_const_flow;
  bool min_const_temp;
  bool max_const_temp;
  bool pump_status;
  bool effective_operation_mode;
  bool effective_control_mode;
  bool capacity;
  bool speed;
  bool lifetime_running_hours;
  bool power;
  bool lifetime_energy_consumed;
  bool operation_mode;
  bool control_mode;
  bool alarm_mask;
} uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_pump_configuration_and_control_state_t,
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_pump_configuration_and_control_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/pump_configuration_and_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_pump_configuration_and_control_write_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/pump_configuration_and_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_pump_configuration_and_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxPressure
 *
 * @param base_topic    topic prefix to publish, /max_pressure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxSpeed
 *
 * @param base_topic    topic prefix to publish, /max_speed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxFlow
 *
 * @param base_topic    topic prefix to publish, /max_flow
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MinConstPressure
 *
 * @param base_topic    topic prefix to publish, /min_const_pressure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxConstPressure
 *
 * @param base_topic    topic prefix to publish, /max_const_pressure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MinCompPressure
 *
 * @param base_topic    topic prefix to publish, /min_comp_pressure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxCompPressure
 *
 * @param base_topic    topic prefix to publish, /max_comp_pressure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MinConstSpeed
 *
 * @param base_topic    topic prefix to publish, /min_const_speed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxConstSpeed
 *
 * @param base_topic    topic prefix to publish, /max_const_speed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MinConstFlow
 *
 * @param base_topic    topic prefix to publish, /min_const_flow
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxConstFlow
 *
 * @param base_topic    topic prefix to publish, /max_const_flow
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MinConstTemp
 *
 * @param base_topic    topic prefix to publish, /min_const_temp
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/MaxConstTemp
 *
 * @param base_topic    topic prefix to publish, /max_const_temp
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/PumpStatus
 *
 * @param base_topic    topic prefix to publish, /pump_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/EffectiveOperationMode
 *
 * @param base_topic    topic prefix to publish, /effective_operation_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/EffectiveControlMode
 *
 * @param base_topic    topic prefix to publish, /effective_control_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/Capacity
 *
 * @param base_topic    topic prefix to publish, /capacity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/Speed
 *
 * @param base_topic    topic prefix to publish, /speed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/LifetimeRunningHours
 *
 * @param base_topic    topic prefix to publish, /lifetime_running_hours
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/Power
 *
 * @param base_topic    topic prefix to publish, /power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed
 *
 * @param base_topic    topic prefix to publish, /lifetime_energy_consumed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/OperationMode
 *
 * @param base_topic    topic prefix to publish, /operation_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/ControlMode
 *
 * @param base_topic    topic prefix to publish, /control_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PumpConfigurationAndControl/Attributes/AlarmMask
 *
 * @param base_topic    topic prefix to publish, /alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the PumpConfigurationAndControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /PumpConfigurationAndControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_pump_configuration_and_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the thermostat cluster
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    SetpointRaiseOrLowerMode mode,

    int8_t amount
);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t number_of_transitions,

    uint8_t day_of_week,

    uint8_t mode,

    TransitionType transitions
);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t number_of_transitions,

    uint8_t day_of_week,

    uint8_t mode,

    TransitionType transitions
);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t time_of_day,

    uint8_t relay_status,

    int16_t local_temperature,

    uint8_t humidity_percentage,

    int16_t set_point,

    uint16_t unread_entries
);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t days_to_return,

    uint8_t mode_to_return
);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);

typedef struct {
  int16_t local_temperature;
  int16_t outdoor_temperature;
  uint8_t occupancy;
  int16_t abs_min_heat_setpoint_limit;
  int16_t abs_max_heat_setpoint_limit;
  int16_t abs_min_cool_setpoint_limit;
  int16_t abs_max_cool_setpoint_limit;
  uint8_t pi_cooling_demand;
  uint8_t pi_heating_demand;
  uint8_t hvac_system_type_configuration;
  int8_t local_temperature_calibration;
  int16_t occupied_cooling_setpoint;
  int16_t occupied_heating_setpoint;
  int16_t unoccupied_cooling_setpoint;
  int16_t unoccupied_heating_setpoint;
  int16_t min_heat_setpoint_limit;
  int16_t max_heat_setpoint_limit;
  int16_t min_cool_setpoint_limit;
  int16_t max_cool_setpoint_limit;
  int8_t min_setpoint_dead_band;
  uint8_t remote_sensing;
  uint8_t control_sequence_of_operation;
  uint8_t system_mode;
  uint8_t alarm_mask;
  uint8_t thermostat_running_mode;
  uint8_t start_of_week;
  uint8_t number_of_weekly_transitions;
  uint8_t number_of_daily_transitions;
  uint8_t temperature_setpoint_hold;
  uint16_t temperature_setpoint_hold_duration;
  uint8_t thermostat_programming_operation_mode;
  uint16_t thermostat_running_state;
  uint8_t setpoint_change_source;
  int16_t setpoint_change_amount;
  UTC setpoint_change_source_timestamp;
  uint8_t occupied_setback;
  uint8_t occupied_setback_min;
  uint8_t occupied_setback_max;
  uint8_t unoccupied_setback;
  uint8_t unoccupied_setback_min;
  uint8_t unoccupied_setback_max;
  uint8_t emergency_heat_delta;
  uint8_t ac_type;
  uint16_t ac_capacity;
  uint8_t ac_refrigerant_type;
  uint8_t ac_compressor_type;
  uint32_t ac_error_code;
  uint8_t ac_louver_position;
  int16_t ac_coil_temperature;
  uint8_t ac_capacity_format;
} uic_mqtt_dotdot_thermostat_state_t;

typedef struct {
  bool local_temperature;
  bool outdoor_temperature;
  bool occupancy;
  bool abs_min_heat_setpoint_limit;
  bool abs_max_heat_setpoint_limit;
  bool abs_min_cool_setpoint_limit;
  bool abs_max_cool_setpoint_limit;
  bool pi_cooling_demand;
  bool pi_heating_demand;
  bool hvac_system_type_configuration;
  bool local_temperature_calibration;
  bool occupied_cooling_setpoint;
  bool occupied_heating_setpoint;
  bool unoccupied_cooling_setpoint;
  bool unoccupied_heating_setpoint;
  bool min_heat_setpoint_limit;
  bool max_heat_setpoint_limit;
  bool min_cool_setpoint_limit;
  bool max_cool_setpoint_limit;
  bool min_setpoint_dead_band;
  bool remote_sensing;
  bool control_sequence_of_operation;
  bool system_mode;
  bool alarm_mask;
  bool thermostat_running_mode;
  bool start_of_week;
  bool number_of_weekly_transitions;
  bool number_of_daily_transitions;
  bool temperature_setpoint_hold;
  bool temperature_setpoint_hold_duration;
  bool thermostat_programming_operation_mode;
  bool thermostat_running_state;
  bool setpoint_change_source;
  bool setpoint_change_amount;
  bool setpoint_change_source_timestamp;
  bool occupied_setback;
  bool occupied_setback_min;
  bool occupied_setback_max;
  bool unoccupied_setback;
  bool unoccupied_setback_min;
  bool unoccupied_setback_max;
  bool emergency_heat_delta;
  bool ac_type;
  bool ac_capacity;
  bool ac_refrigerant_type;
  bool ac_compressor_type;
  bool ac_error_code;
  bool ac_louver_position;
  bool ac_coil_temperature;
  bool ac_capacity_format;
} uic_mqtt_dotdot_thermostat_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_thermostat_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_thermostat_state_t,
    uic_mqtt_dotdot_thermostat_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_thermostat_updated_state_t
);

typedef struct {
  bool setpoint_raise_or_lower;
  bool get_weekly_schedule_response;
  bool set_weekly_schedule;
  bool get_relay_status_log_response;
  bool get_weekly_schedule;
  bool clear_weekly_schedule;
  bool get_relay_status_log;
} uic_mqtt_dotdot_thermostat_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/Thermostat/setpoint_raise_or_lower is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/get_weekly_schedule_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/set_weekly_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/get_relay_status_log_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/get_weekly_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/clear_weekly_schedule is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback);

/**
 * Setup callback to be called when a
 * +/Thermostat/get_relay_status_log is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/thermostat/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/thermostat/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/LocalTemperature
 *
 * @param base_topic    topic prefix to publish, /local_temperature
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OutdoorTemperature
 *
 * @param base_topic    topic prefix to publish, /outdoor_temperature
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/Occupancy
 *
 * @param base_topic    topic prefix to publish, /occupancy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/AbsMinHeatSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /abs_min_heat_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/AbsMaxHeatSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /abs_max_heat_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/AbsMinCoolSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /abs_min_cool_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/AbsMaxCoolSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /abs_max_cool_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/PICoolingDemand
 *
 * @param base_topic    topic prefix to publish, /pi_cooling_demand
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/PIHeatingDemand
 *
 * @param base_topic    topic prefix to publish, /pi_heating_demand
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/HVACSystemTypeConfiguration
 *
 * @param base_topic    topic prefix to publish, /hvac_system_type_configuration
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/LocalTemperatureCalibration
 *
 * @param base_topic    topic prefix to publish, /local_temperature_calibration
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OccupiedCoolingSetpoint
 *
 * @param base_topic    topic prefix to publish, /occupied_cooling_setpoint
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OccupiedHeatingSetpoint
 *
 * @param base_topic    topic prefix to publish, /occupied_heating_setpoint
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/UnoccupiedCoolingSetpoint
 *
 * @param base_topic    topic prefix to publish, /unoccupied_cooling_setpoint
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/UnoccupiedHeatingSetpoint
 *
 * @param base_topic    topic prefix to publish, /unoccupied_heating_setpoint
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/MinHeatSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /min_heat_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/MaxHeatSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /max_heat_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/MinCoolSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /min_cool_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/MaxCoolSetpointLimit
 *
 * @param base_topic    topic prefix to publish, /max_cool_setpoint_limit
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/MinSetpointDeadBand
 *
 * @param base_topic    topic prefix to publish, /min_setpoint_dead_band
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/RemoteSensing
 *
 * @param base_topic    topic prefix to publish, /remote_sensing
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_remote_sensing_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ControlSequenceOfOperation
 *
 * @param base_topic    topic prefix to publish, /control_sequence_of_operation
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/SystemMode
 *
 * @param base_topic    topic prefix to publish, /system_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_system_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/AlarmMask
 *
 * @param base_topic    topic prefix to publish, /alarm_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ThermostatRunningMode
 *
 * @param base_topic    topic prefix to publish, /thermostat_running_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/StartOfWeek
 *
 * @param base_topic    topic prefix to publish, /start_of_week
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_start_of_week_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/NumberOfWeeklyTransitions
 *
 * @param base_topic    topic prefix to publish, /number_of_weekly_transitions
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/NumberOfDailyTransitions
 *
 * @param base_topic    topic prefix to publish, /number_of_daily_transitions
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/TemperatureSetpointHold
 *
 * @param base_topic    topic prefix to publish, /temperature_setpoint_hold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/TemperatureSetpointHoldDuration
 *
 * @param base_topic    topic prefix to publish, /temperature_setpoint_hold_duration
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ThermostatProgrammingOperationMode
 *
 * @param base_topic    topic prefix to publish, /thermostat_programming_operation_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ThermostatRunningState
 *
 * @param base_topic    topic prefix to publish, /thermostat_running_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/SetpointChangeSource
 *
 * @param base_topic    topic prefix to publish, /setpoint_change_source
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/SetpointChangeAmount
 *
 * @param base_topic    topic prefix to publish, /setpoint_change_amount
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/SetpointChangeSourceTimestamp
 *
 * @param base_topic    topic prefix to publish, /setpoint_change_source_timestamp
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OccupiedSetback
 *
 * @param base_topic    topic prefix to publish, /occupied_setback
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OccupiedSetbackMin
 *
 * @param base_topic    topic prefix to publish, /occupied_setback_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/OccupiedSetbackMax
 *
 * @param base_topic    topic prefix to publish, /occupied_setback_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/UnoccupiedSetback
 *
 * @param base_topic    topic prefix to publish, /unoccupied_setback
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/UnoccupiedSetbackMin
 *
 * @param base_topic    topic prefix to publish, /unoccupied_setback_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/UnoccupiedSetbackMax
 *
 * @param base_topic    topic prefix to publish, /unoccupied_setback_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/EmergencyHeatDelta
 *
 * @param base_topic    topic prefix to publish, /emergency_heat_delta
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACType
 *
 * @param base_topic    topic prefix to publish, /ac_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACCapacity
 *
 * @param base_topic    topic prefix to publish, /ac_capacity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACRefrigerantType
 *
 * @param base_topic    topic prefix to publish, /ac_refrigerant_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACCompressorType
 *
 * @param base_topic    topic prefix to publish, /ac_compressor_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACErrorCode
 *
 * @param base_topic    topic prefix to publish, /ac_error_code
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_error_code_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACLouverPosition
 *
 * @param base_topic    topic prefix to publish, /ac_louver_position
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACCoilTemperature
 *
 * @param base_topic    topic prefix to publish, /ac_coil_temperature
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Thermostat/Attributes/ACCapacityFormat
 *
 * @param base_topic    topic prefix to publish, /ac_capacity_format
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Thermostat/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Thermostat/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the fan_control cluster

typedef struct {
  uint8_t fan_mode;
  uint8_t fan_mode_sequence;
} uic_mqtt_dotdot_fan_control_state_t;

typedef struct {
  bool fan_mode;
  bool fan_mode_sequence;
} uic_mqtt_dotdot_fan_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_fan_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_fan_control_state_t,
    uic_mqtt_dotdot_fan_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_fan_control_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_fan_control_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/fan_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_fan_control_write_attributes_callback(
  const uic_mqtt_dotdot_fan_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/fan_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_fan_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; FanControl/Attributes/FanMode
 *
 * @param base_topic    topic prefix to publish, /fan_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; FanControl/Attributes/FanModeSequence
 *
 * @param base_topic    topic prefix to publish, /fan_mode_sequence
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the FanControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /FanControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_fan_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the dehumidification_control cluster

typedef struct {
  uint8_t relative_humidity;
  uint8_t dehumidification_cooling;
  uint8_t rh_dehumidification_setpoint;
  uint8_t relative_humidity_mode;
  uint8_t dehumidification_lockout;
  uint8_t dehumidification_hysteresis;
  uint8_t dehumidification_max_cool;
  uint8_t relative_humidity_display;
} uic_mqtt_dotdot_dehumidification_control_state_t;

typedef struct {
  bool relative_humidity;
  bool dehumidification_cooling;
  bool rh_dehumidification_setpoint;
  bool relative_humidity_mode;
  bool dehumidification_lockout;
  bool dehumidification_hysteresis;
  bool dehumidification_max_cool;
  bool relative_humidity_display;
} uic_mqtt_dotdot_dehumidification_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_dehumidification_control_state_t,
    uic_mqtt_dotdot_dehumidification_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_dehumidification_control_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_dehumidification_control_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/dehumidification_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_dehumidification_control_write_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/dehumidification_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_dehumidification_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/RelativeHumidity
 *
 * @param base_topic    topic prefix to publish, /relative_humidity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/DehumidificationCooling
 *
 * @param base_topic    topic prefix to publish, /dehumidification_cooling
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/RHDehumidificationSetpoint
 *
 * @param base_topic    topic prefix to publish, /rh_dehumidification_setpoint
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/RelativeHumidityMode
 *
 * @param base_topic    topic prefix to publish, /relative_humidity_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/DehumidificationLockout
 *
 * @param base_topic    topic prefix to publish, /dehumidification_lockout
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/DehumidificationHysteresis
 *
 * @param base_topic    topic prefix to publish, /dehumidification_hysteresis
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/DehumidificationMaxCool
 *
 * @param base_topic    topic prefix to publish, /dehumidification_max_cool
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; DehumidificationControl/Attributes/RelativeHumidityDisplay
 *
 * @param base_topic    topic prefix to publish, /relative_humidity_display
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the DehumidificationControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /DehumidificationControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_dehumidification_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the thermostat_user_interface_configuration cluster

typedef struct {
  uint8_t temperature_display_mode;
  uint8_t keypad_lockout;
  uint8_t schedule_programming_visibility;
} uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t;

typedef struct {
  bool temperature_display_mode;
  bool keypad_lockout;
  bool schedule_programming_visibility;
} uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t,
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_thermostat_user_interface_configuration_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/thermostat_user_interface_configuration/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/thermostat_user_interface_configuration/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode
 *
 * @param base_topic    topic prefix to publish, /temperature_display_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout
 *
 * @param base_topic    topic prefix to publish, /keypad_lockout
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility
 *
 * @param base_topic    topic prefix to publish, /schedule_programming_visibility
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the ThermostatUserInterfaceConfiguration/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the color_control cluster
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_to_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_step_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_to_saturation_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_saturation_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_step_saturation_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_to_color_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t colorx,

    uint16_t colory,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_color_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    int16_t ratex,

    int16_t ratey,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_step_color_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    int16_t stepx,

    int16_t stepy,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t color_temperature_mireds,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t enhanced_hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCMoveMode move_mode,

    uint16_t rate,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t enhanced_hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_color_loop_set_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t update_flags,

    ColorLoopSetAction action,

    CCColorLoopDirection direction,

    uint16_t time,

    uint16_t start_hue,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_stop_move_step_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_move_color_temperature_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCMoveMode move_mode,

    uint16_t rate,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override
);
typedef sl_status_t (*uic_mqtt_dotdot_color_control_step_color_temperature_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override
);

typedef struct {
  uint8_t current_hue;
  uint8_t current_saturation;
  uint16_t remaining_time;
  uint16_t currentx;
  uint16_t currenty;
  uint8_t drift_compensation;
  const char* compensation_text;
  uint16_t color_temperature_mireds;
  uint8_t color_mode;
  uint8_t options;
  uint8_t number_of_primaries;
  uint16_t primary1x;
  uint16_t primary1y;
  uint8_t primary1_intensity;
  uint16_t primary2x;
  uint16_t primary2y;
  uint8_t primary2_intensity;
  uint16_t primary3x;
  uint16_t primary3y;
  uint8_t primary3_intensity;
  uint16_t primary4x;
  uint16_t primary4y;
  uint8_t primary4_intensity;
  uint16_t primary5x;
  uint16_t primary5y;
  uint8_t primary5_intensity;
  uint16_t primary6x;
  uint16_t primary6y;
  uint8_t primary6_intensity;
  uint16_t white_pointx;
  uint16_t white_pointy;
  uint16_t color_pointrx;
  uint16_t color_pointry;
  uint8_t color_pointr_intensity;
  uint16_t color_pointgx;
  uint16_t color_pointgy;
  uint8_t color_pointg_intensity;
  uint16_t color_pointbx;
  uint16_t color_pointby;
  uint8_t color_pointb_intensity;
  uint16_t enhanced_current_hue;
  uint8_t enhanced_color_mode;
  uint8_t color_loop_active;
  uint8_t color_loop_direction;
  uint16_t color_loop_time;
  uint16_t color_loop_start_enhanced_hue;
  uint16_t color_loop_stored_enhanced_hue;
  uint16_t color_capabilities;
  uint16_t color_temp_physical_min_mireds;
  uint16_t color_temp_physical_max_mireds;
  uint16_t couple_color_temp_to_level_min_mireds;
  uint16_t start_up_color_temperature_mireds;
} uic_mqtt_dotdot_color_control_state_t;

typedef struct {
  bool current_hue;
  bool current_saturation;
  bool remaining_time;
  bool currentx;
  bool currenty;
  bool drift_compensation;
  bool compensation_text;
  bool color_temperature_mireds;
  bool color_mode;
  bool options;
  bool number_of_primaries;
  bool primary1x;
  bool primary1y;
  bool primary1_intensity;
  bool primary2x;
  bool primary2y;
  bool primary2_intensity;
  bool primary3x;
  bool primary3y;
  bool primary3_intensity;
  bool primary4x;
  bool primary4y;
  bool primary4_intensity;
  bool primary5x;
  bool primary5y;
  bool primary5_intensity;
  bool primary6x;
  bool primary6y;
  bool primary6_intensity;
  bool white_pointx;
  bool white_pointy;
  bool color_pointrx;
  bool color_pointry;
  bool color_pointr_intensity;
  bool color_pointgx;
  bool color_pointgy;
  bool color_pointg_intensity;
  bool color_pointbx;
  bool color_pointby;
  bool color_pointb_intensity;
  bool enhanced_current_hue;
  bool enhanced_color_mode;
  bool color_loop_active;
  bool color_loop_direction;
  bool color_loop_time;
  bool color_loop_start_enhanced_hue;
  bool color_loop_stored_enhanced_hue;
  bool color_capabilities;
  bool color_temp_physical_min_mireds;
  bool color_temp_physical_max_mireds;
  bool couple_color_temp_to_level_min_mireds;
  bool start_up_color_temperature_mireds;
} uic_mqtt_dotdot_color_control_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_color_control_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_color_control_state_t,
    uic_mqtt_dotdot_color_control_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_color_control_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_color_control_updated_state_t
);

typedef struct {
  bool move_to_hue;
  bool move_hue;
  bool step_hue;
  bool move_to_saturation;
  bool move_saturation;
  bool step_saturation;
  bool move_to_hue_and_saturation;
  bool move_to_color;
  bool move_color;
  bool step_color;
  bool move_to_color_temperature;
  bool enhanced_move_to_hue;
  bool enhanced_move_hue;
  bool enhanced_step_hue;
  bool enhanced_move_to_hue_and_saturation;
  bool color_loop_set;
  bool stop_move_step;
  bool move_color_temperature;
  bool step_color_temperature;
} uic_mqtt_dotdot_color_control_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/ColorControl/move_to_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_hue_callback_set(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/step_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_step_hue_callback_set(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_to_saturation is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_to_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_saturation is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/step_saturation is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_step_saturation_callback_set(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_to_hue_and_saturation is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_to_color is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_to_color_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_color is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_color_callback_set(const uic_mqtt_dotdot_color_control_move_color_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/step_color is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_step_color_callback_set(const uic_mqtt_dotdot_color_control_step_color_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_to_color_temperature is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/enhanced_move_to_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/enhanced_move_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/enhanced_step_hue is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/enhanced_move_to_hue_and_saturation is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/color_loop_set is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_color_loop_set_callback_set(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/stop_move_step is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_stop_move_step_callback_set(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/move_color_temperature is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_move_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ColorControl/step_color_temperature is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_color_control_step_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/color_control/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_color_control_write_attributes_callback(
  const uic_mqtt_dotdot_color_control_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/color_control/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_color_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_color_control_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CurrentHue
 *
 * @param base_topic    topic prefix to publish, /current_hue
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_current_hue_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CurrentSaturation
 *
 * @param base_topic    topic prefix to publish, /current_saturation
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_current_saturation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/RemainingTime
 *
 * @param base_topic    topic prefix to publish, /remaining_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CurrentX
 *
 * @param base_topic    topic prefix to publish, /currentx
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_currentx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CurrentY
 *
 * @param base_topic    topic prefix to publish, /currenty
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_currenty_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/DriftCompensation
 *
 * @param base_topic    topic prefix to publish, /drift_compensation
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_drift_compensation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CompensationText
 *
 * @param base_topic    topic prefix to publish, /compensation_text
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_compensation_text_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorTemperatureMireds
 *
 * @param base_topic    topic prefix to publish, /color_temperature_mireds
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorMode
 *
 * @param base_topic    topic prefix to publish, /color_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Options
 *
 * @param base_topic    topic prefix to publish, /options
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/NumberOfPrimaries
 *
 * @param base_topic    topic prefix to publish, /number_of_primaries
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_number_of_primaries_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary1X
 *
 * @param base_topic    topic prefix to publish, /primary1x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary1x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary1Y
 *
 * @param base_topic    topic prefix to publish, /primary1y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary1y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary1Intensity
 *
 * @param base_topic    topic prefix to publish, /primary1_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary1_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary2X
 *
 * @param base_topic    topic prefix to publish, /primary2x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary2x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary2Y
 *
 * @param base_topic    topic prefix to publish, /primary2y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary2y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary2Intensity
 *
 * @param base_topic    topic prefix to publish, /primary2_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary2_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary3X
 *
 * @param base_topic    topic prefix to publish, /primary3x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary3x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary3Y
 *
 * @param base_topic    topic prefix to publish, /primary3y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary3y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary3Intensity
 *
 * @param base_topic    topic prefix to publish, /primary3_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary3_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary4X
 *
 * @param base_topic    topic prefix to publish, /primary4x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary4x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary4Y
 *
 * @param base_topic    topic prefix to publish, /primary4y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary4y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary4Intensity
 *
 * @param base_topic    topic prefix to publish, /primary4_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary4_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary5X
 *
 * @param base_topic    topic prefix to publish, /primary5x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary5x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary5Y
 *
 * @param base_topic    topic prefix to publish, /primary5y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary5y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary5Intensity
 *
 * @param base_topic    topic prefix to publish, /primary5_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary5_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary6X
 *
 * @param base_topic    topic prefix to publish, /primary6x
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary6x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary6Y
 *
 * @param base_topic    topic prefix to publish, /primary6y
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary6y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/Primary6Intensity
 *
 * @param base_topic    topic prefix to publish, /primary6_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_primary6_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/WhitePointX
 *
 * @param base_topic    topic prefix to publish, /white_pointx
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_white_pointx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/WhitePointY
 *
 * @param base_topic    topic prefix to publish, /white_pointy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_white_pointy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointRX
 *
 * @param base_topic    topic prefix to publish, /color_pointrx
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointrx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointRY
 *
 * @param base_topic    topic prefix to publish, /color_pointry
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointRIntensity
 *
 * @param base_topic    topic prefix to publish, /color_pointr_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointGX
 *
 * @param base_topic    topic prefix to publish, /color_pointgx
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointgx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointGY
 *
 * @param base_topic    topic prefix to publish, /color_pointgy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointgy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointGIntensity
 *
 * @param base_topic    topic prefix to publish, /color_pointg_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointBX
 *
 * @param base_topic    topic prefix to publish, /color_pointbx
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointbx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointBY
 *
 * @param base_topic    topic prefix to publish, /color_pointby
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointby_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorPointBIntensity
 *
 * @param base_topic    topic prefix to publish, /color_pointb_intensity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/EnhancedCurrentHue
 *
 * @param base_topic    topic prefix to publish, /enhanced_current_hue
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/EnhancedColorMode
 *
 * @param base_topic    topic prefix to publish, /enhanced_color_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorLoopActive
 *
 * @param base_topic    topic prefix to publish, /color_loop_active
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_loop_active_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorLoopDirection
 *
 * @param base_topic    topic prefix to publish, /color_loop_direction
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_loop_direction_publish(
  const char *base_topic,
  CCColorLoopDirection value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorLoopTime
 *
 * @param base_topic    topic prefix to publish, /color_loop_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_loop_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorLoopStartEnhancedHue
 *
 * @param base_topic    topic prefix to publish, /color_loop_start_enhanced_hue
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorLoopStoredEnhancedHue
 *
 * @param base_topic    topic prefix to publish, /color_loop_stored_enhanced_hue
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorCapabilities
 *
 * @param base_topic    topic prefix to publish, /color_capabilities
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_capabilities_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorTempPhysicalMinMireds
 *
 * @param base_topic    topic prefix to publish, /color_temp_physical_min_mireds
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/ColorTempPhysicalMaxMireds
 *
 * @param base_topic    topic prefix to publish, /color_temp_physical_max_mireds
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/CoupleColorTempToLevelMinMireds
 *
 * @param base_topic    topic prefix to publish, /couple_color_temp_to_level_min_mireds
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ColorControl/Attributes/StartUpColorTemperatureMireds
 *
 * @param base_topic    topic prefix to publish, /start_up_color_temperature_mireds
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the ColorControl/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /ColorControl/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_color_control_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the ballast_configuration cluster

typedef struct {
  uint8_t physical_min_level;
  uint8_t physical_max_level;
  uint8_t ballast_status;
  uint8_t min_level;
  uint8_t max_level;
  uint8_t power_on_level;
  uint16_t power_on_fade_time;
  uint8_t intrinsic_ballast_factor;
  uint8_t ballast_factor_adjustment;
  uint8_t lamp_quantity;
  const char* lamp_type;
  const char* lamp_manufacturer;
  uint32_t lamp_rated_hours;
  uint32_t lamp_burn_hours;
  uint8_t lamp_alarm_mode;
  uint32_t lamp_burn_hours_trip_point;
} uic_mqtt_dotdot_ballast_configuration_state_t;

typedef struct {
  bool physical_min_level;
  bool physical_max_level;
  bool ballast_status;
  bool min_level;
  bool max_level;
  bool power_on_level;
  bool power_on_fade_time;
  bool intrinsic_ballast_factor;
  bool ballast_factor_adjustment;
  bool lamp_quantity;
  bool lamp_type;
  bool lamp_manufacturer;
  bool lamp_rated_hours;
  bool lamp_burn_hours;
  bool lamp_alarm_mode;
  bool lamp_burn_hours_trip_point;
} uic_mqtt_dotdot_ballast_configuration_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ballast_configuration_state_t,
    uic_mqtt_dotdot_ballast_configuration_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ballast_configuration_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_ballast_configuration_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/ballast_configuration/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ballast_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/ballast_configuration/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ballast_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/PhysicalMinLevel
 *
 * @param base_topic    topic prefix to publish, /physical_min_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/PhysicalMaxLevel
 *
 * @param base_topic    topic prefix to publish, /physical_max_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/BallastStatus
 *
 * @param base_topic    topic prefix to publish, /ballast_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/MinLevel
 *
 * @param base_topic    topic prefix to publish, /min_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/MaxLevel
 *
 * @param base_topic    topic prefix to publish, /max_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/PowerOnLevel
 *
 * @param base_topic    topic prefix to publish, /power_on_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/PowerOnFadeTime
 *
 * @param base_topic    topic prefix to publish, /power_on_fade_time
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/IntrinsicBallastFactor
 *
 * @param base_topic    topic prefix to publish, /intrinsic_ballast_factor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/BallastFactorAdjustment
 *
 * @param base_topic    topic prefix to publish, /ballast_factor_adjustment
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampQuantity
 *
 * @param base_topic    topic prefix to publish, /lamp_quantity
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampType
 *
 * @param base_topic    topic prefix to publish, /lamp_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampManufacturer
 *
 * @param base_topic    topic prefix to publish, /lamp_manufacturer
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampRatedHours
 *
 * @param base_topic    topic prefix to publish, /lamp_rated_hours
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampBurnHours
 *
 * @param base_topic    topic prefix to publish, /lamp_burn_hours
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampAlarmMode
 *
 * @param base_topic    topic prefix to publish, /lamp_alarm_mode
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; BallastConfiguration/Attributes/LampBurnHoursTripPoint
 *
 * @param base_topic    topic prefix to publish, /lamp_burn_hours_trip_point
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the BallastConfiguration/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /BallastConfiguration/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_ballast_configuration_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the illuminance_measurement cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
  uint8_t light_sensor_type;
} uic_mqtt_dotdot_illuminance_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
  bool light_sensor_type;
} uic_mqtt_dotdot_illuminance_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_illuminance_measurement_state_t,
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_illuminance_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/illuminance_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_illuminance_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/illuminance_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_illuminance_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; IlluminanceMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceMeasurement/Attributes/LightSensorType
 *
 * @param base_topic    topic prefix to publish, /light_sensor_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the IlluminanceMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /IlluminanceMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_illuminance_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the illuminance_level_sensing cluster

typedef struct {
  uint8_t level_status;
  uint8_t light_sensor_type;
  uint16_t illuminance_target_level;
} uic_mqtt_dotdot_illuminance_level_sensing_state_t;

typedef struct {
  bool level_status;
  bool light_sensor_type;
  bool illuminance_target_level;
} uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_illuminance_level_sensing_state_t,
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_illuminance_level_sensing_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/illuminance_level_sensing/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_illuminance_level_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/illuminance_level_sensing/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_illuminance_level_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; IlluminanceLevelSensing/Attributes/LevelStatus
 *
 * @param base_topic    topic prefix to publish, /level_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceLevelSensing/Attributes/LightSensorType
 *
 * @param base_topic    topic prefix to publish, /light_sensor_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel
 *
 * @param base_topic    topic prefix to publish, /illuminance_target_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the IlluminanceLevelSensing/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /IlluminanceLevelSensing/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_illuminance_level_sensing_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the temperature_measurement cluster

typedef struct {
  int16_t measured_value;
  int16_t min_measured_value;
  int16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_temperature_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_temperature_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_temperature_measurement_state_t,
    uic_mqtt_dotdot_temperature_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_temperature_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_temperature_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/temperature_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_temperature_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/temperature_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_temperature_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; TemperatureMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; TemperatureMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; TemperatureMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; TemperatureMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the TemperatureMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /TemperatureMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the pressure_measurement cluster

typedef struct {
  int16_t measured_value;
  int16_t min_measured_value;
  int16_t max_measured_value;
  uint16_t tolerance;
  int16_t scaled_value;
  int16_t min_scaled_value;
  int16_t max_scaled_value;
  uint16_t scaled_tolerance;
  int8_t scale;
} uic_mqtt_dotdot_pressure_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
  bool scaled_value;
  bool min_scaled_value;
  bool max_scaled_value;
  bool scaled_tolerance;
  bool scale;
} uic_mqtt_dotdot_pressure_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_pressure_measurement_state_t,
    uic_mqtt_dotdot_pressure_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_pressure_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_pressure_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/pressure_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_pressure_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/pressure_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_pressure_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/ScaledValue
 *
 * @param base_topic    topic prefix to publish, /scaled_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/MinScaledValue
 *
 * @param base_topic    topic prefix to publish, /min_scaled_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/MaxScaledValue
 *
 * @param base_topic    topic prefix to publish, /max_scaled_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/ScaledTolerance
 *
 * @param base_topic    topic prefix to publish, /scaled_tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PressureMeasurement/Attributes/Scale
 *
 * @param base_topic    topic prefix to publish, /scale
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_pressure_measurement_scale_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the PressureMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /PressureMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_pressure_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the flow_measurement cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_flow_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_flow_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_flow_measurement_state_t,
    uic_mqtt_dotdot_flow_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_flow_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_flow_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/flow_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_flow_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/flow_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_flow_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; FlowMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_flow_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; FlowMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; FlowMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; FlowMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_flow_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the FlowMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /FlowMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_flow_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the relativity_humidity cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_relativity_humidity_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_relativity_humidity_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_relativity_humidity_state_t,
    uic_mqtt_dotdot_relativity_humidity_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_relativity_humidity_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_relativity_humidity_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/relativity_humidity/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_relativity_humidity_write_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/relativity_humidity/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_relativity_humidity_force_read_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; RelativityHumidity/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; RelativityHumidity/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; RelativityHumidity/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; RelativityHumidity/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the RelativityHumidity/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /RelativityHumidity/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_relativity_humidity_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the occupancy_sensing cluster

typedef struct {
  uint8_t occupancy;
  uint8_t occupancy_sensor_type;
  uint8_t occupancy_sensor_type_bitmap;
  uint16_t pir_occupied_to_unoccupied_delay;
  uint16_t pir_unoccupied_to_occupied_delay;
  uint8_t pir_unoccupied_to_occupied_threshold;
  uint16_t ultrasonic_occupied_to_unoccupied_delay;
  uint16_t ultrasonic_unoccupied_to_occupied_delay;
  uint8_t ultrasonic_unoccupied_to_occupied_threshold;
  uint16_t physical_contact_occupied_to_unoccupied_delay;
  uint16_t physical_contact_unoccupied_to_occupied_delay;
  uint8_t physical_contact_unoccupied_to_occupied_threshold;
} uic_mqtt_dotdot_occupancy_sensing_state_t;

typedef struct {
  bool occupancy;
  bool occupancy_sensor_type;
  bool occupancy_sensor_type_bitmap;
  bool pir_occupied_to_unoccupied_delay;
  bool pir_unoccupied_to_occupied_delay;
  bool pir_unoccupied_to_occupied_threshold;
  bool ultrasonic_occupied_to_unoccupied_delay;
  bool ultrasonic_unoccupied_to_occupied_delay;
  bool ultrasonic_unoccupied_to_occupied_threshold;
  bool physical_contact_occupied_to_unoccupied_delay;
  bool physical_contact_unoccupied_to_occupied_delay;
  bool physical_contact_unoccupied_to_occupied_threshold;
} uic_mqtt_dotdot_occupancy_sensing_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_occupancy_sensing_state_t,
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_occupancy_sensing_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/occupancy_sensing/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/occupancy_sensing/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_occupancy_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/Occupancy
 *
 * @param base_topic    topic prefix to publish, /occupancy
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/OccupancySensorType
 *
 * @param base_topic    topic prefix to publish, /occupancy_sensor_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/OccupancySensorTypeBitmap
 *
 * @param base_topic    topic prefix to publish, /occupancy_sensor_type_bitmap
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /pir_occupied_to_unoccupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /pir_unoccupied_to_occupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold
 *
 * @param base_topic    topic prefix to publish, /pir_unoccupied_to_occupied_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /ultrasonic_occupied_to_unoccupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /ultrasonic_unoccupied_to_occupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold
 *
 * @param base_topic    topic prefix to publish, /ultrasonic_unoccupied_to_occupied_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /physical_contact_occupied_to_unoccupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay
 *
 * @param base_topic    topic prefix to publish, /physical_contact_unoccupied_to_occupied_delay
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold
 *
 * @param base_topic    topic prefix to publish, /physical_contact_unoccupied_to_occupied_threshold
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the OccupancySensing/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /OccupancySensing/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the ph_measurement cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_ph_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_ph_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ph_measurement_state_t,
    uic_mqtt_dotdot_ph_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ph_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_ph_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/ph_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ph_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/ph_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ph_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; PhMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ph_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PhMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PhMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; PhMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ph_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the PhMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /PhMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_ph_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the electrical_conductivity_measurement cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_electrical_conductivity_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_electrical_conductivity_measurement_state_t,
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_electrical_conductivity_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/electrical_conductivity_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_electrical_conductivity_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/electrical_conductivity_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_electrical_conductivity_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; ElectricalConductivityMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalConductivityMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalConductivityMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the ElectricalConductivityMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /ElectricalConductivityMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the wind_speed_measurement cluster

typedef struct {
  uint16_t measured_value;
  uint16_t min_measured_value;
  uint16_t max_measured_value;
  uint16_t tolerance;
} uic_mqtt_dotdot_wind_speed_measurement_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_wind_speed_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_wind_speed_measurement_state_t,
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_wind_speed_measurement_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/wind_speed_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_wind_speed_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/wind_speed_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_wind_speed_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; WindSpeedMeasurement/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindSpeedMeasurement/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindSpeedMeasurement/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; WindSpeedMeasurement/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the WindSpeedMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /WindSpeedMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_wind_speed_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the carbon_monoxide cluster

typedef struct {
  float measured_value;
  float min_measured_value;
  float max_measured_value;
  float tolerance;
} uic_mqtt_dotdot_carbon_monoxide_state_t;

typedef struct {
  bool measured_value;
  bool min_measured_value;
  bool max_measured_value;
  bool tolerance;
} uic_mqtt_dotdot_carbon_monoxide_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_carbon_monoxide_state_t,
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_carbon_monoxide_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/carbon_monoxide/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_carbon_monoxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/carbon_monoxide/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_carbon_monoxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; CarbonMonoxide/Attributes/MeasuredValue
 *
 * @param base_topic    topic prefix to publish, /measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; CarbonMonoxide/Attributes/MinMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /min_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; CarbonMonoxide/Attributes/MaxMeasuredValue
 *
 * @param base_topic    topic prefix to publish, /max_measured_value
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; CarbonMonoxide/Attributes/Tolerance
 *
 * @param base_topic    topic prefix to publish, /tolerance
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the CarbonMonoxide/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /CarbonMonoxide/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_carbon_monoxide_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the ias_zone cluster
typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    ZoneEnrollResponseEnrollResponseCode enroll_response_code,

    uint8_t zoneid
);
typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint16_t zone_status,

    uint8_t extended_status,

    uint8_t zoneid,

    uint16_t delay
);
typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    IasZoneType zone_type,

    uint16_t manufacturer_code
);
typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t test_mode_duration,

    uint8_t current_zone_sensitivity_level
);

typedef struct {
  uint8_t zone_state;
  uint8_t zone_type;
  uint16_t zone_status;
  EUI64 iascie_address;
  uint8_t zoneid;
  uint8_t number_of_zone_sensitivity_levels_supported;
  uint8_t current_zone_sensitivity_level;
} uic_mqtt_dotdot_ias_zone_state_t;

typedef struct {
  bool zone_state;
  bool zone_type;
  bool zone_status;
  bool iascie_address;
  bool zoneid;
  bool number_of_zone_sensitivity_levels_supported;
  bool current_zone_sensitivity_level;
} uic_mqtt_dotdot_ias_zone_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ias_zone_state_t,
    uic_mqtt_dotdot_ias_zone_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_ias_zone_updated_state_t
);

typedef struct {
  bool zone_enroll_response;
  bool zone_status_change_notification;
  bool initiate_normal_operation_mode;
  bool zone_enroll_request;
  bool initiate_test_mode;
} uic_mqtt_dotdot_ias_zone_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/IASZone/zone_enroll_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/IASZone/zone_status_change_notification is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback);

/**
 * Setup callback to be called when a
 * +/IASZone/initiate_normal_operation_mode is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback);

/**
 * Setup callback to be called when a
 * +/IASZone/zone_enroll_request is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback);

/**
 * Setup callback to be called when a
 * +/IASZone/initiate_test_mode is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/ias_zone/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/ias_zone/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_ias_zone_force_read_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; IASZone/Attributes/ZoneState
 *
 * @param base_topic    topic prefix to publish, /zone_state
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_zone_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/ZoneType
 *
 * @param base_topic    topic prefix to publish, /zone_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_zone_type_publish(
  const char *base_topic,
  IasZoneType value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/ZoneStatus
 *
 * @param base_topic    topic prefix to publish, /zone_status
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_zone_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/IASCIEAddress
 *
 * @param base_topic    topic prefix to publish, /iascie_address
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_iascie_address_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/ZoneID
 *
 * @param base_topic    topic prefix to publish, /zoneid
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_zoneid_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported
 *
 * @param base_topic    topic prefix to publish, /number_of_zone_sensitivity_levels_supported
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; IASZone/Attributes/CurrentZoneSensitivityLevel
 *
 * @param base_topic    topic prefix to publish, /current_zone_sensitivity_level
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the IASZone/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /IASZone/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_ias_zone_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the iaswd cluster
typedef sl_status_t (*uic_mqtt_dotdot_iaswd_start_warning_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t siren_configuration,

    uint16_t warning_duration,

    uint8_t strobe_duty_cycle,

    IaswdLevel strobe_level
);
typedef sl_status_t (*uic_mqtt_dotdot_iaswd_squawk_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t squawk_configuration
);

typedef struct {
  uint16_t max_duration;
} uic_mqtt_dotdot_iaswd_state_t;

typedef struct {
  bool max_duration;
} uic_mqtt_dotdot_iaswd_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_iaswd_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_iaswd_state_t,
    uic_mqtt_dotdot_iaswd_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_iaswd_updated_state_t
);

typedef struct {
  bool start_warning;
  bool squawk;
} uic_mqtt_dotdot_iaswd_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/IASWD/start_warning is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_iaswd_start_warning_callback_set(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback);

/**
 * Setup callback to be called when a
 * +/IASWD/squawk is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_iaswd_squawk_callback_set(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/iaswd/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
  const uic_mqtt_dotdot_iaswd_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/iaswd/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_iaswd_force_read_attributes_callback(
  const uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; IASWD/Attributes/MaxDuration
 *
 * @param base_topic    topic prefix to publish, /max_duration
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_iaswd_max_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the IASWD/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /IASWD/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_iaswd_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the electrical_measurement cluster
typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uint8_t profile_count,

    ProfileIntervalPeriod profile_interval_period,

    uint8_t max_number_of_intervals,

    attribId list_of_attributes
);
typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type);
typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    UTC start_time,

    GetMeasurementProfileResponseStatus status,

    ProfileIntervalPeriod profile_interval_period,

    uint8_t number_of_intervals_delivered,

    attribId attribute_id,

    /* TYPE WARNING: unk defaults to */ uint8_t *  intervals
);
typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t)(
    dotdot_unid_t unid,
    dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    attribId attributeid,

    UTC start_time,

    uint8_t number_of_intervals
);

typedef struct {
  uint32_t measurement_type;
  int16_t dc_voltage;
  int16_t dc_voltage_min;
  int16_t dc_voltage_max;
  int16_t dc_current;
  int16_t dc_current_min;
  int16_t dc_current_max;
  int16_t dc_power;
  int16_t dc_power_min;
  int16_t dc_power_max;
  uint16_t dc_voltage_multiplier;
  uint16_t dc_voltage_divisor;
  uint16_t dc_current_multiplier;
  uint16_t dc_current_divisor;
  uint16_t dc_power_multiplier;
  uint16_t dc_power_divisor;
  uint16_t ac_frequency;
  uint16_t ac_frequency_min;
  uint16_t ac_frequency_max;
  uint16_t neutral_current;
  int32_t total_active_power;
  int32_t total_reactive_power;
  uint32_t total_apparent_power;
  int16_t measured1st_harmonic_current;
  int16_t measured3rd_harmonic_current;
  int16_t measured5th_harmonic_current;
  int16_t measured7th_harmonic_current;
  int16_t measured9th_harmonic_current;
  int16_t measured11th_harmonic_current;
  int16_t measured_phase1st_harmonic_current;
  int16_t measured_phase3rd_harmonic_current;
  int16_t measured_phase5th_harmonic_current;
  int16_t measured_phase7th_harmonic_current;
  int16_t measured_phase9th_harmonic_current;
  int16_t measured_phase11th_harmonic_current;
  uint16_t ac_frequency_multiplier;
  uint16_t ac_frequency_divisor;
  uint32_t power_multiplier;
  uint32_t power_divisor;
  int8_t harmonic_current_multiplier;
  int8_t phase_harmonic_current_multiplier;
  uint16_t line_current;
  int16_t active_current;
  int16_t reactive_current;
  uint16_t rms_voltage;
  uint16_t rms_voltage_min;
  uint16_t rms_voltage_max;
  uint16_t rms_current;
  uint16_t rms_current_min;
  uint16_t rms_current_max;
  int16_t active_power;
  int16_t active_power_min;
  int16_t active_power_max;
  int16_t reactive_power;
  uint16_t apparent_power;
  int8_t power_factor;
  uint16_t averagerms_voltage_measurement_period;
  uint16_t averagerms_over_voltage_counter;
  uint16_t averagerms_under_voltage_counter;
  uint16_t rms_extreme_over_voltage_period;
  uint16_t rms_extreme_under_voltage_period;
  uint16_t rms_voltage_sag_period;
  uint16_t rms_voltage_swell_period;
  uint16_t ac_voltage_multiplier;
  uint16_t ac_voltage_divisor;
  uint16_t ac_current_multiplier;
  uint16_t ac_current_divisor;
  uint16_t ac_power_multiplier;
  uint16_t ac_power_divisor;
  uint8_t dc_overload_alarms_mask;
  int16_t dc_voltage_overload;
  int16_t dc_current_overload;
  uint16_t ac_alarms_mask;
  int16_t ac_voltage_overload;
  int16_t ac_current_overload;
  int16_t ac_active_power_overload;
  int16_t ac_reactive_power_overload;
  int16_t averagerms_over_voltage;
  int16_t averagerms_under_voltage;
  int16_t rms_extreme_over_voltage;
  int16_t rms_extreme_under_voltage;
  int16_t rms_voltage_sag;
  int16_t rms_voltage_swell;
  uint16_t line_current_phb;
  int16_t active_current_phb;
  int16_t reactive_current_phb;
  uint16_t rms_voltage_phb;
  uint16_t rms_voltage_min_phb;
  uint16_t rms_voltage_max_phb;
  uint16_t rms_current_phb;
  uint16_t rms_current_min_phb;
  uint16_t rms_current_max_phb;
  int16_t active_power_phb;
  int16_t active_power_min_phb;
  int16_t active_power_max_phb;
  int16_t reactive_power_phb;
  uint16_t apparent_power_phb;
  int8_t power_factor_phb;
  uint16_t averagerms_voltage_measurement_period_phb;
  uint16_t averagerms_over_voltage_counter_phb;
  uint16_t averagerms_under_voltage_counter_phb;
  uint16_t rms_extreme_over_voltage_period_phb;
  uint16_t rms_extreme_under_voltage_period_phb;
  uint16_t rms_voltage_sag_period_phb;
  uint16_t rms_voltage_swell_period_phb;
  uint16_t line_current_phc;
  int16_t active_current_phc;
  int16_t reactive_current_phc;
  uint16_t rms_voltage_phc;
  uint16_t rms_voltage_min_phc;
  uint16_t rms_voltage_max_phc;
  uint16_t rms_current_phc;
  uint16_t rms_current_min_phc;
  uint16_t rms_current_max_phc;
  int16_t active_power_phc;
  int16_t active_power_min_phc;
  int16_t active_power_max_phc;
  int16_t reactive_power_phc;
  uint16_t apparent_power_phc;
  int8_t power_factor_phc;
  uint16_t averagerms_voltage_measurement_period_phc;
  uint16_t averagerms_over_voltage_counter_phc;
  uint16_t averagerms_under_voltage_counter_phc;
  uint16_t rms_extreme_over_voltage_period_phc;
  uint16_t rms_extreme_under_voltage_period_phc;
  uint16_t rms_voltage_sag_period_phc;
  uint16_t rms_voltage_swell_period_phc;
} uic_mqtt_dotdot_electrical_measurement_state_t;

typedef struct {
  bool measurement_type;
  bool dc_voltage;
  bool dc_voltage_min;
  bool dc_voltage_max;
  bool dc_current;
  bool dc_current_min;
  bool dc_current_max;
  bool dc_power;
  bool dc_power_min;
  bool dc_power_max;
  bool dc_voltage_multiplier;
  bool dc_voltage_divisor;
  bool dc_current_multiplier;
  bool dc_current_divisor;
  bool dc_power_multiplier;
  bool dc_power_divisor;
  bool ac_frequency;
  bool ac_frequency_min;
  bool ac_frequency_max;
  bool neutral_current;
  bool total_active_power;
  bool total_reactive_power;
  bool total_apparent_power;
  bool measured1st_harmonic_current;
  bool measured3rd_harmonic_current;
  bool measured5th_harmonic_current;
  bool measured7th_harmonic_current;
  bool measured9th_harmonic_current;
  bool measured11th_harmonic_current;
  bool measured_phase1st_harmonic_current;
  bool measured_phase3rd_harmonic_current;
  bool measured_phase5th_harmonic_current;
  bool measured_phase7th_harmonic_current;
  bool measured_phase9th_harmonic_current;
  bool measured_phase11th_harmonic_current;
  bool ac_frequency_multiplier;
  bool ac_frequency_divisor;
  bool power_multiplier;
  bool power_divisor;
  bool harmonic_current_multiplier;
  bool phase_harmonic_current_multiplier;
  bool line_current;
  bool active_current;
  bool reactive_current;
  bool rms_voltage;
  bool rms_voltage_min;
  bool rms_voltage_max;
  bool rms_current;
  bool rms_current_min;
  bool rms_current_max;
  bool active_power;
  bool active_power_min;
  bool active_power_max;
  bool reactive_power;
  bool apparent_power;
  bool power_factor;
  bool averagerms_voltage_measurement_period;
  bool averagerms_over_voltage_counter;
  bool averagerms_under_voltage_counter;
  bool rms_extreme_over_voltage_period;
  bool rms_extreme_under_voltage_period;
  bool rms_voltage_sag_period;
  bool rms_voltage_swell_period;
  bool ac_voltage_multiplier;
  bool ac_voltage_divisor;
  bool ac_current_multiplier;
  bool ac_current_divisor;
  bool ac_power_multiplier;
  bool ac_power_divisor;
  bool dc_overload_alarms_mask;
  bool dc_voltage_overload;
  bool dc_current_overload;
  bool ac_alarms_mask;
  bool ac_voltage_overload;
  bool ac_current_overload;
  bool ac_active_power_overload;
  bool ac_reactive_power_overload;
  bool averagerms_over_voltage;
  bool averagerms_under_voltage;
  bool rms_extreme_over_voltage;
  bool rms_extreme_under_voltage;
  bool rms_voltage_sag;
  bool rms_voltage_swell;
  bool line_current_phb;
  bool active_current_phb;
  bool reactive_current_phb;
  bool rms_voltage_phb;
  bool rms_voltage_min_phb;
  bool rms_voltage_max_phb;
  bool rms_current_phb;
  bool rms_current_min_phb;
  bool rms_current_max_phb;
  bool active_power_phb;
  bool active_power_min_phb;
  bool active_power_max_phb;
  bool reactive_power_phb;
  bool apparent_power_phb;
  bool power_factor_phb;
  bool averagerms_voltage_measurement_period_phb;
  bool averagerms_over_voltage_counter_phb;
  bool averagerms_under_voltage_counter_phb;
  bool rms_extreme_over_voltage_period_phb;
  bool rms_extreme_under_voltage_period_phb;
  bool rms_voltage_sag_period_phb;
  bool rms_voltage_swell_period_phb;
  bool line_current_phc;
  bool active_current_phc;
  bool reactive_current_phc;
  bool rms_voltage_phc;
  bool rms_voltage_min_phc;
  bool rms_voltage_max_phc;
  bool rms_current_phc;
  bool rms_current_min_phc;
  bool rms_current_max_phc;
  bool active_power_phc;
  bool active_power_min_phc;
  bool active_power_max_phc;
  bool reactive_power_phc;
  bool apparent_power_phc;
  bool power_factor_phc;
  bool averagerms_voltage_measurement_period_phc;
  bool averagerms_over_voltage_counter_phc;
  bool averagerms_under_voltage_counter_phc;
  bool rms_extreme_over_voltage_period_phc;
  bool rms_extreme_under_voltage_period_phc;
  bool rms_voltage_sag_period_phc;
  bool rms_voltage_swell_period_phc;
} uic_mqtt_dotdot_electrical_measurement_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_electrical_measurement_state_t,
    uic_mqtt_dotdot_electrical_measurement_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_electrical_measurement_updated_state_t
);

typedef struct {
  bool get_profile_info_response;
  bool get_profile_info;
  bool get_measurement_profile_response;
  bool get_measurement_profile;
} uic_mqtt_dotdot_electrical_measurement_supported_commands_t;
/**
 * Setup callback to be called when a
 * +/ElectricalMeasurement/get_profile_info_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ElectricalMeasurement/get_profile_info is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ElectricalMeasurement/get_measurement_profile_response is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback);

/**
 * Setup callback to be called when a
 * +/ElectricalMeasurement/get_measurement_profile is received. Setting
 * this callback will overwrite the previous set callback
 */
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback);

/**
 * Setup a callback for WriteAttribute to be called when a
 * +/electrical_measurement/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_electrical_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/electrical_measurement/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_electrical_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasurementType
 *
 * @param base_topic    topic prefix to publish, /measurement_type
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltage
 *
 * @param base_topic    topic prefix to publish, /dc_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltageMin
 *
 * @param base_topic    topic prefix to publish, /dc_voltage_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltageMax
 *
 * @param base_topic    topic prefix to publish, /dc_voltage_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrent
 *
 * @param base_topic    topic prefix to publish, /dc_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrentMin
 *
 * @param base_topic    topic prefix to publish, /dc_current_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrentMax
 *
 * @param base_topic    topic prefix to publish, /dc_current_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCPower
 *
 * @param base_topic    topic prefix to publish, /dc_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCPowerMin
 *
 * @param base_topic    topic prefix to publish, /dc_power_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCPowerMax
 *
 * @param base_topic    topic prefix to publish, /dc_power_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltageMultiplier
 *
 * @param base_topic    topic prefix to publish, /dc_voltage_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltageDivisor
 *
 * @param base_topic    topic prefix to publish, /dc_voltage_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrentMultiplier
 *
 * @param base_topic    topic prefix to publish, /dc_current_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrentDivisor
 *
 * @param base_topic    topic prefix to publish, /dc_current_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCPowerMultiplier
 *
 * @param base_topic    topic prefix to publish, /dc_power_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCPowerDivisor
 *
 * @param base_topic    topic prefix to publish, /dc_power_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACFrequency
 *
 * @param base_topic    topic prefix to publish, /ac_frequency
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACFrequencyMin
 *
 * @param base_topic    topic prefix to publish, /ac_frequency_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACFrequencyMax
 *
 * @param base_topic    topic prefix to publish, /ac_frequency_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/NeutralCurrent
 *
 * @param base_topic    topic prefix to publish, /neutral_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/TotalActivePower
 *
 * @param base_topic    topic prefix to publish, /total_active_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/TotalReactivePower
 *
 * @param base_topic    topic prefix to publish, /total_reactive_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/TotalApparentPower
 *
 * @param base_topic    topic prefix to publish, /total_apparent_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured1st_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured3rd_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured5th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured7th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured9th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured11th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase1st_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase3rd_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase5th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase7th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase9th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent
 *
 * @param base_topic    topic prefix to publish, /measured_phase11th_harmonic_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACFrequencyMultiplier
 *
 * @param base_topic    topic prefix to publish, /ac_frequency_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACFrequencyDivisor
 *
 * @param base_topic    topic prefix to publish, /ac_frequency_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PowerMultiplier
 *
 * @param base_topic    topic prefix to publish, /power_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PowerDivisor
 *
 * @param base_topic    topic prefix to publish, /power_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier
 *
 * @param base_topic    topic prefix to publish, /harmonic_current_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier
 *
 * @param base_topic    topic prefix to publish, /phase_harmonic_current_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/LineCurrent
 *
 * @param base_topic    topic prefix to publish, /line_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActiveCurrent
 *
 * @param base_topic    topic prefix to publish, /active_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactiveCurrent
 *
 * @param base_topic    topic prefix to publish, /reactive_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltage
 *
 * @param base_topic    topic prefix to publish, /rms_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMin
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMax
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrent
 *
 * @param base_topic    topic prefix to publish, /rms_current
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMin
 *
 * @param base_topic    topic prefix to publish, /rms_current_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMax
 *
 * @param base_topic    topic prefix to publish, /rms_current_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePower
 *
 * @param base_topic    topic prefix to publish, /active_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMin
 *
 * @param base_topic    topic prefix to publish, /active_power_min
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMax
 *
 * @param base_topic    topic prefix to publish, /active_power_max
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactivePower
 *
 * @param base_topic    topic prefix to publish, /reactive_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ApparentPower
 *
 * @param base_topic    topic prefix to publish, /apparent_power
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PowerFactor
 *
 * @param base_topic    topic prefix to publish, /power_factor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod
 *
 * @param base_topic    topic prefix to publish, /averagerms_voltage_measurement_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter
 *
 * @param base_topic    topic prefix to publish, /averagerms_over_voltage_counter
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter
 *
 * @param base_topic    topic prefix to publish, /averagerms_under_voltage_counter
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_over_voltage_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_under_voltage_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSagPeriod
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_sag_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_swell_period
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACVoltageMultiplier
 *
 * @param base_topic    topic prefix to publish, /ac_voltage_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACVoltageDivisor
 *
 * @param base_topic    topic prefix to publish, /ac_voltage_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACCurrentMultiplier
 *
 * @param base_topic    topic prefix to publish, /ac_current_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACCurrentDivisor
 *
 * @param base_topic    topic prefix to publish, /ac_current_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACPowerMultiplier
 *
 * @param base_topic    topic prefix to publish, /ac_power_multiplier
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACPowerDivisor
 *
 * @param base_topic    topic prefix to publish, /ac_power_divisor
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCOverloadAlarmsMask
 *
 * @param base_topic    topic prefix to publish, /dc_overload_alarms_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCVoltageOverload
 *
 * @param base_topic    topic prefix to publish, /dc_voltage_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/DCCurrentOverload
 *
 * @param base_topic    topic prefix to publish, /dc_current_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACAlarmsMask
 *
 * @param base_topic    topic prefix to publish, /ac_alarms_mask
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACVoltageOverload
 *
 * @param base_topic    topic prefix to publish, /ac_voltage_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACCurrentOverload
 *
 * @param base_topic    topic prefix to publish, /ac_current_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACActivePowerOverload
 *
 * @param base_topic    topic prefix to publish, /ac_active_power_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ACReactivePowerOverload
 *
 * @param base_topic    topic prefix to publish, /ac_reactive_power_overload
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSOverVoltage
 *
 * @param base_topic    topic prefix to publish, /averagerms_over_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSUnderVoltage
 *
 * @param base_topic    topic prefix to publish, /averagerms_under_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeOverVoltage
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_over_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_under_voltage
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSag
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_sag
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSwell
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_swell
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/LineCurrentPhB
 *
 * @param base_topic    topic prefix to publish, /line_current_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActiveCurrentPhB
 *
 * @param base_topic    topic prefix to publish, /active_current_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactiveCurrentPhB
 *
 * @param base_topic    topic prefix to publish, /reactive_current_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltagePhB
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMinPhB
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_min_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMaxPhB
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_max_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentPhB
 *
 * @param base_topic    topic prefix to publish, /rms_current_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMinPhB
 *
 * @param base_topic    topic prefix to publish, /rms_current_min_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMaxPhB
 *
 * @param base_topic    topic prefix to publish, /rms_current_max_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerPhB
 *
 * @param base_topic    topic prefix to publish, /active_power_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMinPhB
 *
 * @param base_topic    topic prefix to publish, /active_power_min_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMaxPhB
 *
 * @param base_topic    topic prefix to publish, /active_power_max_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactivePowerPhB
 *
 * @param base_topic    topic prefix to publish, /reactive_power_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ApparentPowerPhB
 *
 * @param base_topic    topic prefix to publish, /apparent_power_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PowerFactorPhB
 *
 * @param base_topic    topic prefix to publish, /power_factor_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB
 *
 * @param base_topic    topic prefix to publish, /averagerms_voltage_measurement_period_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB
 *
 * @param base_topic    topic prefix to publish, /averagerms_over_voltage_counter_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB
 *
 * @param base_topic    topic prefix to publish, /averagerms_under_voltage_counter_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_over_voltage_period_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_under_voltage_period_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_sag_period_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_swell_period_phb
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/LineCurrentPhC
 *
 * @param base_topic    topic prefix to publish, /line_current_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActiveCurrentPhC
 *
 * @param base_topic    topic prefix to publish, /active_current_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactiveCurrentPhC
 *
 * @param base_topic    topic prefix to publish, /reactive_current_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltagePhC
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMinPhC
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_min_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageMaxPhC
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_max_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentPhC
 *
 * @param base_topic    topic prefix to publish, /rms_current_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMinPhC
 *
 * @param base_topic    topic prefix to publish, /rms_current_min_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSCurrentMaxPhC
 *
 * @param base_topic    topic prefix to publish, /rms_current_max_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerPhC
 *
 * @param base_topic    topic prefix to publish, /active_power_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMinPhC
 *
 * @param base_topic    topic prefix to publish, /active_power_min_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ActivePowerMaxPhC
 *
 * @param base_topic    topic prefix to publish, /active_power_max_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ReactivePowerPhC
 *
 * @param base_topic    topic prefix to publish, /reactive_power_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/ApparentPowerPhC
 *
 * @param base_topic    topic prefix to publish, /apparent_power_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/PowerFactorPhC
 *
 * @param base_topic    topic prefix to publish, /power_factor_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC
 *
 * @param base_topic    topic prefix to publish, /averagerms_voltage_measurement_period_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_voltage_measurement_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC
 *
 * @param base_topic    topic prefix to publish, /averagerms_over_voltage_counter_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_over_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC
 *
 * @param base_topic    topic prefix to publish, /averagerms_under_voltage_counter_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_averagerms_under_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_over_voltage_period_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC
 *
 * @param base_topic    topic prefix to publish, /rms_extreme_under_voltage_period_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_sag_period_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC
 *
 * @param base_topic    topic prefix to publish, /rms_voltage_swell_period_phc
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the ElectricalMeasurement/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /ElectricalMeasurement/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(const char* base_topic, uint16_t value);

// Callback types used by the diagnostics cluster

typedef struct {
  uint16_t number_of_resets;
  uint16_t persistent_memory_writes;
  uint32_t mac_rx_bcast;
  uint32_t mac_tx_bcast;
  uint32_t mac_rx_ucast;
  uint32_t mac_tx_ucast;
  uint16_t mac_tx_ucast_retry;
  uint16_t mac_tx_ucast_fail;
  uint16_t aps_rx_bcast;
  uint16_t aps_tx_bcast;
  uint16_t aps_rx_ucast;
  uint16_t aps_tx_ucast_success;
  uint16_t aps_tx_ucast_retry;
  uint16_t aps_tx_ucast_fail;
  uint16_t route_disc_initiated;
  uint16_t neighbor_added;
  uint16_t neighbor_removed;
  uint16_t neighbor_stale;
  uint16_t join_indication;
  uint16_t child_moved;
  uint16_t nwkfc_failure;
  uint16_t apsfc_failure;
  uint16_t aps_unauthorized_key;
  uint16_t nwk_decrypt_failures;
  uint16_t aps_decrypt_failures;
  uint16_t packet_buffer_allocate_failures;
  uint16_t relayed_ucast;
  uint16_t phy_tomac_queue_limit_reached;
  uint16_t packet_validate_drop_count;
  uint16_t averagemac_retry_peraps_message_sent;
  uint8_t last_messagelqi;
  int8_t last_messagerssi;
} uic_mqtt_dotdot_diagnostics_state_t;

typedef struct {
  bool number_of_resets;
  bool persistent_memory_writes;
  bool mac_rx_bcast;
  bool mac_tx_bcast;
  bool mac_rx_ucast;
  bool mac_tx_ucast;
  bool mac_tx_ucast_retry;
  bool mac_tx_ucast_fail;
  bool aps_rx_bcast;
  bool aps_tx_bcast;
  bool aps_rx_ucast;
  bool aps_tx_ucast_success;
  bool aps_tx_ucast_retry;
  bool aps_tx_ucast_fail;
  bool route_disc_initiated;
  bool neighbor_added;
  bool neighbor_removed;
  bool neighbor_stale;
  bool join_indication;
  bool child_moved;
  bool nwkfc_failure;
  bool apsfc_failure;
  bool aps_unauthorized_key;
  bool nwk_decrypt_failures;
  bool aps_decrypt_failures;
  bool packet_buffer_allocate_failures;
  bool relayed_ucast;
  bool phy_tomac_queue_limit_reached;
  bool packet_validate_drop_count;
  bool averagemac_retry_peraps_message_sent;
  bool last_messagelqi;
  bool last_messagerssi;
} uic_mqtt_dotdot_diagnostics_updated_state_t;

typedef sl_status_t (*uic_mqtt_dotdot_diagnostics_write_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_diagnostics_state_t,
    uic_mqtt_dotdot_diagnostics_updated_state_t
);

typedef sl_status_t (*uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t)(
    const dotdot_unid_t unid,
    const dotdot_endpoint_id_t endpoint,
    uic_mqtt_dotdot_callback_call_type_t call_type,
    uic_mqtt_dotdot_diagnostics_updated_state_t
);

typedef struct {
  bool dummy;
} uic_mqtt_dotdot_diagnostics_supported_commands_t;
/**
 * Setup a callback for WriteAttribute to be called when a
 * +/diagnostics/Commands/WriteAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_diagnostics_write_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_write_attributes_callback_t callback
);

/**
 * Setup a callback for ForceReadAttributes to be called when a
 * +/diagnostics/Commands/ForceReadAttributes is received. Setting this callback
 * will overwrite any previously set callback
 */
void uic_mqtt_dotdot_set_diagnostics_force_read_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t callback
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NumberOfResets
 *
 * @param base_topic    topic prefix to publish, /number_of_resets
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/PersistentMemoryWrites
 *
 * @param base_topic    topic prefix to publish, /persistent_memory_writes
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacRxBcast
 *
 * @param base_topic    topic prefix to publish, /mac_rx_bcast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacTxBcast
 *
 * @param base_topic    topic prefix to publish, /mac_tx_bcast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacRxUcast
 *
 * @param base_topic    topic prefix to publish, /mac_rx_ucast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacTxUcast
 *
 * @param base_topic    topic prefix to publish, /mac_tx_ucast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacTxUcastRetry
 *
 * @param base_topic    topic prefix to publish, /mac_tx_ucast_retry
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/MacTxUcastFail
 *
 * @param base_topic    topic prefix to publish, /mac_tx_ucast_fail
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSRxBcast
 *
 * @param base_topic    topic prefix to publish, /aps_rx_bcast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSTxBcast
 *
 * @param base_topic    topic prefix to publish, /aps_tx_bcast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSRxUcast
 *
 * @param base_topic    topic prefix to publish, /aps_rx_ucast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSTxUcastSuccess
 *
 * @param base_topic    topic prefix to publish, /aps_tx_ucast_success
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSTxUcastRetry
 *
 * @param base_topic    topic prefix to publish, /aps_tx_ucast_retry
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSTxUcastFail
 *
 * @param base_topic    topic prefix to publish, /aps_tx_ucast_fail
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/RouteDiscInitiated
 *
 * @param base_topic    topic prefix to publish, /route_disc_initiated
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NeighborAdded
 *
 * @param base_topic    topic prefix to publish, /neighbor_added
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NeighborRemoved
 *
 * @param base_topic    topic prefix to publish, /neighbor_removed
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NeighborStale
 *
 * @param base_topic    topic prefix to publish, /neighbor_stale
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/JoinIndication
 *
 * @param base_topic    topic prefix to publish, /join_indication
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_join_indication_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/ChildMoved
 *
 * @param base_topic    topic prefix to publish, /child_moved
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_child_moved_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NWKFCFailure
 *
 * @param base_topic    topic prefix to publish, /nwkfc_failure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSFCFailure
 *
 * @param base_topic    topic prefix to publish, /apsfc_failure
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSUnauthorizedKey
 *
 * @param base_topic    topic prefix to publish, /aps_unauthorized_key
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/NWKDecryptFailures
 *
 * @param base_topic    topic prefix to publish, /nwk_decrypt_failures
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/APSDecryptFailures
 *
 * @param base_topic    topic prefix to publish, /aps_decrypt_failures
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/PacketBufferAllocateFailures
 *
 * @param base_topic    topic prefix to publish, /packet_buffer_allocate_failures
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/RelayedUcast
 *
 * @param base_topic    topic prefix to publish, /relayed_ucast
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/PHYToMACQueueLimitReached
 *
 * @param base_topic    topic prefix to publish, /phy_tomac_queue_limit_reached
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_phy_tomac_queue_limit_reached_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/PacketValidateDropCount
 *
 * @param base_topic    topic prefix to publish, /packet_validate_drop_count
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent
 *
 * @param base_topic    topic prefix to publish, /averagemac_retry_peraps_message_sent
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_averagemac_retry_peraps_message_sent_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/LastMessageLQI
 *
 * @param base_topic    topic prefix to publish, /last_messagelqi
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);

/**
 * @brief Publish the attribute; Diagnostics/Attributes/LastMessageRSSI
 *
 * @param base_topic    topic prefix to publish, /last_messagerssi
 *                      will be appended
 * @param value         Value to publish
 * @param publish_type  Whether to publish as Desired, Reported, or Both.
 * @return SL_STATUS_OK on success
 */
sl_status_t uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
);


/**
 * @brief Publish the Diagnostics/ClusterRevision attribute
 *
 * @param base_topic    topic prefix to publish, /Diagnostics/Attributes/ClusterRevision
 *                      will be appended.
 * @param value         Value to publish.
 */
void uic_mqtt_dotdot_diagnostics_publish_cluster_revision(const char* base_topic, uint16_t value);


/**
 * @brief Publish the SupportedCommands for UNID/EndPoint
 *
 * This function will iterate over all Commands in all Clusters and call all
 * registered callback functions with unid, endpoint, and
 * callback_type = UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK. All Cluster
 * Command callback functions that return SL_STATUS_OK  will be added to the
 * list of supported commands and published.
 *
 * @param unid
 * @param endpoint
 */
void uic_mqtt_dotdot_publish_supported_commands(
  dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint);

/**
* Function definition used to register a Group dispatch function from a Protocol
* Controller.
* Incoming publications at ucl/by-group/+/&lt;Cluster&gt;/Commands/&lt;Command&gt; will be
* forwarded to this function.
* @param group_id       Group ID of the group to dispatch.
* @param cluster_name   The name of the Cluster for which the command was received
* @param command        The Command that was received within the Cluster.
* @param message        The MQTT message/payload received for the command
* @param message_length The length of the MQTT message/payload received for the
*                       Command.
* @param callback MQTT subscription callback that is normally used for individual
*                 Command dispatch for the cluster.
*/
typedef void (*group_dispatch_t)(uint16_t group_id,
                                 const char *cluster_name,
                                 const char *command,
                                 const char *message,
                                 size_t message_length,
                                 mqtt_message_callback_t callback);

/**
 * @brief Setup Group dispatch callback
 *
 * This function will set the callback used when a ucl/by-group/# is received
 * and subscribe to all by-group topics handlers supported by the Protocol
 * Controller. Setting this callback will overwrite any previously set
 * callback but will not resubscribe to the topic handlers.
 *
 * @param callback
 */
void uic_mqtt_dotdot_set_group_dispatch_callback(group_dispatch_t callback);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // DOTDOT_MQTT_H
/** @} end dotdot_mqtt */
