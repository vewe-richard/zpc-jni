#include <sl_status.h>

const char* sl_status_string(int status) {
  switch (status) {
    case SL_STATUS_OK: return "SL_STATUS_OK";
    case SL_STATUS_FAIL: return "SL_STATUS_FAIL";
    case SL_STATUS_INVALID_STATE: return "SL_STATUS_INVALID_STATE";
    case SL_STATUS_NOT_READY: return "SL_STATUS_NOT_READY";
    case SL_STATUS_BUSY: return "SL_STATUS_BUSY";
    case SL_STATUS_IN_PROGRESS: return "SL_STATUS_IN_PROGRESS";
    case SL_STATUS_ABORT: return "SL_STATUS_ABORT";
    case SL_STATUS_TIMEOUT: return "SL_STATUS_TIMEOUT";
    case SL_STATUS_PERMISSION: return "SL_STATUS_PERMISSION";
    case SL_STATUS_WOULD_BLOCK: return "SL_STATUS_WOULD_BLOCK";
    case SL_STATUS_IDLE: return "SL_STATUS_IDLE";
    case SL_STATUS_IS_WAITING: return "SL_STATUS_IS_WAITING";
    case SL_STATUS_NONE_WAITING: return "SL_STATUS_NONE_WAITING";
    case SL_STATUS_SUSPENDED: return "SL_STATUS_SUSPENDED";
    case SL_STATUS_NOT_AVAILABLE: return "SL_STATUS_NOT_AVAILABLE";
    case SL_STATUS_NOT_SUPPORTED: return "SL_STATUS_NOT_SUPPORTED";
    case SL_STATUS_INITIALIZATION: return "SL_STATUS_INITIALIZATION";
    case SL_STATUS_NOT_INITIALIZED: return "SL_STATUS_NOT_INITIALIZED";
    case SL_STATUS_ALREADY_INITIALIZED: return "SL_STATUS_ALREADY_INITIALIZED";
    case SL_STATUS_DELETED: return "SL_STATUS_DELETED";
    case SL_STATUS_ISR: return "SL_STATUS_ISR";
    case SL_STATUS_NETWORK_UP: return "SL_STATUS_NETWORK_UP";
    case SL_STATUS_NETWORK_DOWN: return "SL_STATUS_NETWORK_DOWN";
    case SL_STATUS_NOT_JOINED: return "SL_STATUS_NOT_JOINED";
    case SL_STATUS_NO_BEACONS: return "SL_STATUS_NO_BEACONS";
    case SL_STATUS_ALLOCATION_FAILED: return "SL_STATUS_ALLOCATION_FAILED";
    case SL_STATUS_NO_MORE_RESOURCE: return "SL_STATUS_NO_MORE_RESOURCE";
    case SL_STATUS_EMPTY: return "SL_STATUS_EMPTY";
    case SL_STATUS_FULL: return "SL_STATUS_FULL";
    case SL_STATUS_WOULD_OVERFLOW: return "SL_STATUS_WOULD_OVERFLOW";
    case SL_STATUS_OWNERSHIP: return "SL_STATUS_OWNERSHIP";
    case SL_STATUS_IS_OWNER: return "SL_STATUS_IS_OWNER";
    case SL_STATUS_INVALID_PARAMETER: return "SL_STATUS_INVALID_PARAMETER";
    case SL_STATUS_NULL_POINTER: return "SL_STATUS_NULL_POINTER";
    case SL_STATUS_INVALID_CONFIGURATION: return "SL_STATUS_INVALID_CONFIGURATION";
    case SL_STATUS_INVALID_MODE: return "SL_STATUS_INVALID_MODE";
    case SL_STATUS_INVALID_HANDLE: return "SL_STATUS_INVALID_HANDLE";
    case SL_STATUS_INVALID_TYPE: return "SL_STATUS_INVALID_TYPE";
    case SL_STATUS_INVALID_INDEX: return "SL_STATUS_INVALID_INDEX";
    case SL_STATUS_INVALID_RANGE: return "SL_STATUS_INVALID_RANGE";
    case SL_STATUS_INVALID_KEY: return "SL_STATUS_INVALID_KEY";
    case SL_STATUS_INVALID_CREDENTIALS: return "SL_STATUS_INVALID_CREDENTIALS";
    case SL_STATUS_INVALID_COUNT: return "SL_STATUS_INVALID_COUNT";
    case SL_STATUS_INVALID_SIGNATURE: return "SL_STATUS_INVALID_SIGNATURE";
    case SL_STATUS_NOT_FOUND: return "SL_STATUS_NOT_FOUND";
    case SL_STATUS_ALREADY_EXISTS: return "SL_STATUS_ALREADY_EXISTS";
    case SL_STATUS_IO: return "SL_STATUS_IO";
    case SL_STATUS_IO_TIMEOUT: return "SL_STATUS_IO_TIMEOUT";
    case SL_STATUS_TRANSMIT: return "SL_STATUS_TRANSMIT";
    case SL_STATUS_TRANSMIT_UNDERFLOW: return "SL_STATUS_TRANSMIT_UNDERFLOW";
    case SL_STATUS_TRANSMIT_INCOMPLETE: return "SL_STATUS_TRANSMIT_INCOMPLETE";
    case SL_STATUS_TRANSMIT_BUSY: return "SL_STATUS_TRANSMIT_BUSY";
    case SL_STATUS_RECEIVE: return "SL_STATUS_RECEIVE";
    case SL_STATUS_OBJECT_READ: return "SL_STATUS_OBJECT_READ";
    case SL_STATUS_OBJECT_WRITE: return "SL_STATUS_OBJECT_WRITE";
    case SL_STATUS_MESSAGE_TOO_LONG: return "SL_STATUS_MESSAGE_TOO_LONG";
    case SL_STATUS_ERRNO: return "SL_STATUS_ERRNO";
    case SL_STATUS_NET_MQTT_NO_CONN: return "SL_STATUS_NET_MQTT_NO_CONN";
    case SL_STATUS_NET_MQTT_LOST_CONN: return "SL_STATUS_NET_MQTT_LOST_CONN";
    case SL_STATUS_NET_MQTT_PROTOCOL: return "SL_STATUS_NET_MQTT_PROTOCOL";
    case SL_STATUS_NET_MQTT_TLS_HANDSHAKE: return "SL_STATUS_NET_MQTT_TLS_HANDSHAKE";
    case SL_STATUS_NET_MQTT_PAYLOAD_SIZE: return "SL_STATUS_NET_MQTT_PAYLOAD_SIZE";
    case SL_STATUS_NET_MQTT_NOT_SUPPORTED: return "SL_STATUS_NET_MQTT_NOT_SUPPORTED";
    case SL_STATUS_NET_MQTT_AUTH: return "SL_STATUS_NET_MQTT_AUTH";
    case SL_STATUS_NET_MQTT_ACL_DENIED: return "SL_STATUS_NET_MQTT_ACL_DENIED";
    case SL_STATUS_NET_MQTT_MALFORMED_UTF8: return "SL_STATUS_NET_MQTT_MALFORMED_UTF8";
    case SL_STATUS_NET_MQTT_DUPLICATE_PROPERTY: return "SL_STATUS_NET_MQTT_DUPLICATE_PROPERTY";
    case SL_STATUS_NET_MQTT_QOS_NOT_SUPPORTED: return "SL_STATUS_NET_MQTT_QOS_NOT_SUPPORTED";
    case SL_STATUS_NET_MQTT_OVERSIZE_PACKET: return "SL_STATUS_NET_MQTT_OVERSIZE_PACKET";
    default: return "UNKNOWN";
  }
}

const char* sl_status_string_verbose(int status) {
  switch (status) {
    case SL_STATUS_OK: return "No error.";
    case SL_STATUS_FAIL: return "Generic error.";
    case SL_STATUS_INVALID_STATE: return "Generic invalid state error.";
    case SL_STATUS_NOT_READY: return "Module is not ready for requested operation.";
    case SL_STATUS_BUSY: return "Module is busy and cannot carry out requested operation.";
    case SL_STATUS_IN_PROGRESS: return "Operation is in progress and not yet complete (pass or fail).";
    case SL_STATUS_ABORT: return "Operation aborted.";
    case SL_STATUS_TIMEOUT: return "Operation timed out.";
    case SL_STATUS_PERMISSION: return "Operation not allowed per permissions.";
    case SL_STATUS_WOULD_BLOCK: return "Non-blocking operation would block.";
    case SL_STATUS_IDLE: return "Operation/module is Idle, cannot carry requested operation.";
    case SL_STATUS_IS_WAITING: return "Operation cannot be done while construct is waiting.";
    case SL_STATUS_NONE_WAITING: return "No task/construct waiting/pending for that action/event.";
    case SL_STATUS_SUSPENDED: return "Operation cannot be done while construct is suspended.";
    case SL_STATUS_NOT_AVAILABLE: return "Feature not available due to software configuration.";
    case SL_STATUS_NOT_SUPPORTED: return "Feature not supported.";
    case SL_STATUS_INITIALIZATION: return "Initialization failed.";
    case SL_STATUS_NOT_INITIALIZED: return "Module has not been initialized.";
    case SL_STATUS_ALREADY_INITIALIZED: return "Module has already been initialized.";
    case SL_STATUS_DELETED: return "Object/construct has been deleted.";
    case SL_STATUS_ISR: return "Illegal call from ISR.";
    case SL_STATUS_NETWORK_UP: return "Illegal call because network is up.";
    case SL_STATUS_NETWORK_DOWN: return "Illegal call because network is down.";
    case SL_STATUS_NOT_JOINED: return "Failure due to not being joined in a network.";
    case SL_STATUS_NO_BEACONS: return "Invalid operation as there are no beacons.";
    case SL_STATUS_ALLOCATION_FAILED: return "Generic allocation error.";
    case SL_STATUS_NO_MORE_RESOURCE: return "No more resource available to perform the operation.";
    case SL_STATUS_EMPTY: return "Item/list/queue is empty.";
    case SL_STATUS_FULL: return "Item/list/queue is full.";
    case SL_STATUS_WOULD_OVERFLOW: return "Item would overflow.";
    case SL_STATUS_OWNERSHIP: return "Generic ownership error.";
    case SL_STATUS_IS_OWNER: return "Already/still owning resource.";
    case SL_STATUS_INVALID_PARAMETER: return "Generic invalid argument or consequence of invalid argument.";
    case SL_STATUS_NULL_POINTER: return "Invalid null pointer received as argument.";
    case SL_STATUS_INVALID_CONFIGURATION: return "Invalid configuration provided.";
    case SL_STATUS_INVALID_MODE: return "Invalid mode.";
    case SL_STATUS_INVALID_HANDLE: return "Invalid handle.";
    case SL_STATUS_INVALID_TYPE: return "Invalid type for operation.";
    case SL_STATUS_INVALID_INDEX: return "Invalid index.";
    case SL_STATUS_INVALID_RANGE: return "Invalid range.";
    case SL_STATUS_INVALID_KEY: return "Invalid key.";
    case SL_STATUS_INVALID_CREDENTIALS: return "Invalid credentials.";
    case SL_STATUS_INVALID_COUNT: return "Invalid count.";
    case SL_STATUS_INVALID_SIGNATURE: return "Invalid signature / verification failed.";
    case SL_STATUS_NOT_FOUND: return "Item could not be found.";
    case SL_STATUS_ALREADY_EXISTS: return "Item already exists.";
    case SL_STATUS_IO: return "Generic I/O failure.";
    case SL_STATUS_IO_TIMEOUT: return "I/O failure due to timeout.";
    case SL_STATUS_TRANSMIT: return "Generic transmission error.";
    case SL_STATUS_TRANSMIT_UNDERFLOW: return "Transmit underflowed.";
    case SL_STATUS_TRANSMIT_INCOMPLETE: return "Transmit is incomplete.";
    case SL_STATUS_TRANSMIT_BUSY: return "Transmit is busy.";
    case SL_STATUS_RECEIVE: return "Generic reception error.";
    case SL_STATUS_OBJECT_READ: return "Failed to read on/via given object.";
    case SL_STATUS_OBJECT_WRITE: return "Failed to write on/via given object.";
    case SL_STATUS_MESSAGE_TOO_LONG: return "Message is too long.";
    case SL_STATUS_ERRNO: return "System error";
    case SL_STATUS_NET_MQTT_NO_CONN: return "Not connected to a broker.";
    case SL_STATUS_NET_MQTT_LOST_CONN: return "Connection to broker lost.";
    case SL_STATUS_NET_MQTT_PROTOCOL: return "Protocol error.";
    case SL_STATUS_NET_MQTT_TLS_HANDSHAKE: return "TLS negotiation failed.";
    case SL_STATUS_NET_MQTT_PAYLOAD_SIZE: return "Payload size is too large.";
    case SL_STATUS_NET_MQTT_NOT_SUPPORTED: return "MQTTv5 properties are set but client is not using MQTTv5.";
    case SL_STATUS_NET_MQTT_AUTH: return "Authentication failed.";
    case SL_STATUS_NET_MQTT_ACL_DENIED: return "Access control list deny.";
    case SL_STATUS_NET_MQTT_MALFORMED_UTF8: return "Malformed UTF-8 string in the specified MQTT-topic.";
    case SL_STATUS_NET_MQTT_DUPLICATE_PROPERTY: return "An MQTTv5 property is duplicated where it is forbidden.";
    case SL_STATUS_NET_MQTT_QOS_NOT_SUPPORTED: return "The requested QoS level is not supported by the broker.";
    case SL_STATUS_NET_MQTT_OVERSIZE_PACKET: return "Resulting packet will become larger than the broker supports.";
    default: return "Unknown error.";
  }
}
